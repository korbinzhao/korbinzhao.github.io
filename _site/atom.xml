<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>Joebon's world</title>
   <link href="http://joebon.cc/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://joebon.cc" rel="alternate" type="text/html" />
   <updated>2015-10-27T21:43:58+08:00</updated>
   <id>http://joebon.cc</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>原生JS实现页面滚动方向检测</title>
     <link href="http://korbinzhao.github.io/js-scroll-direction"/>
     <updated>2015-10-27T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/js-scroll-direction</id>
     <content type="html">&lt;p&gt;判断页面滚动方向是一个常见的需求，下面展示一个使用原生JS方式判断页面滚动方向的解决方式。&lt;/p&gt;

&lt;h2&gt;html&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://g.tbcdn.cn/tb/kimi/0.0.233/kimi.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;body style=&quot;height: 6000px;&quot;&amp;gt;
    &amp;lt;div class=&quot;nav&quot; style=&quot;position:fixed; top:0;left:0;width: 100%;height: 60px;background-color: pink;&quot;&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;js&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  var $nav = $(&#39;.nav&#39;);
  var $result = $(&#39;.result&#39;);

  //页面滚动监听事件
  window.onscroll = function(e){
    $result.html(&#39;swipeDown&#39;);
    scrollFunc();
    if(scrollDirection == &#39;down&#39;){
      $nav.css({
        position: &#39;absolute&#39;
      });
    }
    else if(scrollDirection == &#39;up&#39;){
      $nav.css({
        position: &#39;fixed&#39;
      });
    }
  }
  var scrollAction = {x: &#39;undefined&#39;, y: &#39;undefined&#39;}, scrollDirection;

  //判断页面滚动方向
  function scrollFunc() {
    if (typeof scrollAction.x == &#39;undefined&#39;) {
      scrollAction.x = window.pageXOffset;
      scrollAction.y = window.pageYOffset;
    }
    var diffX = scrollAction.x - window.pageXOffset;
    var diffY = scrollAction.y - window.pageYOffset;
    if (diffX &amp;lt; 0) {
    // Scroll right
      scrollDirection = &#39;right&#39;;
    } else if (diffX &amp;gt; 0) {
    // Scroll left
      scrollDirection = &#39;left&#39;;
    } else if (diffY &amp;lt; 0) {
    // Scroll down
      scrollDirection = &#39;down&#39;;
    } else if (diffY &amp;gt; 0) {
    // Scroll up
      scrollDirection = &#39;up&#39;;
    } else {
    // First scroll event
    }
    scrollAction.x = window.pageXOffset;
    scrollAction.y = window.pageYOffset;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;github地址&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/korbinzhao/exercise/blob/master/js-scroll-direction.html
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>前端模块化规范 - CommonJS、AMD & CMD</title>
     <link href="http://korbinzhao.github.io/commonjs-amd-cmd"/>
     <updated>2015-10-25T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/commonjs-amd-cmd</id>
     <content type="html">&lt;p&gt;前端为什么会出现模块化这个概念，主要原因是随着前端项目的复杂性和项目团队规模的扩大，命名冲突和文件依赖成为影响前端开发效率的两个重要问题。模块化规范的另一个目的是提高JS程序的可移植性。&lt;/p&gt;

&lt;h2&gt;CommonJS&lt;/h2&gt;

&lt;p&gt;官方JavaScript规范定义的API主要是为了构建基于浏览器端的应用程序。在服务器端，并没有官方的API定义。&lt;/p&gt;

&lt;p&gt;CommonJS定义了许多普通应用程序（主要指非浏览器应用）使用的API，它的终极目标是提供一个类似Python、Ruby和Java的标准库，从而开发者可以使用CommonJS API编写可以运行在不同JS解释器和不同主机环境的应用程序。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NodeJS和CommonJS之间的关系&lt;/p&gt;

&lt;p&gt;  CommonJS是一种规范，NodeJS是这种规范的实现。JavaScript作为本地变成语言这种特殊应用程序，也是随着NodeJS的火热而进入大众的视野。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;浏览器加载 CommonJS 模块的原理与实现&lt;/p&gt;

&lt;p&gt;  npm的模块都是JS语言写的，但是浏览器用不了，因为浏览器不支持CommonJS格式。要想让浏览器用上这些模块，必须转换格式。&lt;/p&gt;

&lt;p&gt;  浏览器不兼容CommonJS的根本原因，在于缺少四个Node.js环境的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  module
  exports
  require
  global
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  只要能够提供这四个变量，浏览器就能加载CommonJS模块。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Browserify的实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;知道了原理，就能做出工具了。Browserify（require(&#39;modules&#39;) in the browser）是目前最常用的CommonJS格式转换的工具。&lt;/p&gt;

&lt;p&gt;举例：
main.js模块加载foo.js模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// foo.js
module.exports = function(x) {
  console.log(x);
};

// main.js
var foo = require(&quot;./foo&quot;);
foo(&quot;Hi&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面的命令，就能将main.js转为浏览器可用的格式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ browserify main.js &amp;gt; compiled.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Browserify到底做了什么？安装一下browser-unpack，就能看清楚了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install browser-unpack -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，将前面生成的compile.js解包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ browser-unpack &amp;lt; compiled.js

[
  {
    &quot;id&quot;:1,
    &quot;source&quot;:&quot;module.exports = function(x) {\n  console.log(x);\n};&quot;,
    &quot;deps&quot;:{}
  },
  {
    &quot;id&quot;:2,
    &quot;source&quot;:&quot;var foo = require(\&quot;./foo\&quot;);\nfoo(\&quot;Hi\&quot;);&quot;,
    &quot;deps&quot;:{&quot;./foo&quot;:1},
    &quot;entry&quot;:true
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，browerify将所有模块放入一个数组，id属性是模块的编号，source属性是模块的源码，deps属性是模块的依赖。&lt;/p&gt;

&lt;p&gt;因为main.js里面加载了foo.js，所以deps属性就制定./foo对应的1号模块。执行的时候，浏览器遇到require(&#39;./foo&#39;)语句，就自动执行1号模块的source属性，并就爱那个执行后的module.exports属性值输出。&lt;/p&gt;

&lt;h2&gt;AMD&lt;/h2&gt;

&lt;p&gt;AMD（异步模块定，Asynchronous Module Definition）格式总体的目标是为现在的开发者提供一个可用的模块化JS解决方案。&lt;/p&gt;

&lt;p&gt;CommonJS通过引入模块化使得在服务器端编写JS应用成为可能，但是由于一个重大的局限，使得CommonJS规范不适用与浏览器环境。举例如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var math = require(&#39;math&#39;);
　　math.add(2, 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二行math.add(2, 3)，在第一行require(&#39;math&#39;)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。&lt;/p&gt;

&lt;p&gt;这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这确实一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于“假死”状态。&lt;/p&gt;

&lt;p&gt;因此，浏览器端的模块，不能采用“同步加载”（synchronous），只能采用“异步加载”（asynchronous）。这就是AMD规范诞生的背景。&lt;/p&gt;

&lt;p&gt;AMD是“Asynchronous Module Definition”的缩写，意思就是“异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。&lt;/p&gt;

&lt;p&gt;AMD也采用require()语句加载模块，但是不同于CommonJS，他要求两个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require([module], callback);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。&lt;/p&gt;

&lt;h2&gt;CMD&lt;/h2&gt;

&lt;p&gt;CMD（Common Module Definition）模块定义规范，是@玉伯提出的一个类似于AMD的规范，该规范明确了模块的基本书写格式和基本交互规则。&lt;/p&gt;

&lt;h3&gt;AMD和CMD的区别&lt;/h3&gt;

&lt;p&gt;下面来看下@玉伯给出的官方解释。&lt;/p&gt;

&lt;p&gt;AMD和CMD等规范的目的都是为了JS的模块化开发，特别是在浏览器端的。目前这些规范的实现都能达成浏览器端模块化开发的目的。&lt;/p&gt;

&lt;p&gt;区别在于：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于依赖的模块，AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD推崇as lazy as possible。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CMD推崇依赖就近，AMD推崇依赖前置。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; // CMD
 define(function(require, exports, module) {   
     var a = require(&#39;./a&#39;)   
     a.doSomething()   
     // 此处略去 100 行   
     var b = require(&#39;./b&#39;) // 依赖可以就近书写   
     b.doSomething()   
     // ... 
 })

 // AMD 默认推荐的是
 define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) {  
     // 依赖必须一开始就写好    
     a.doSomething()    
     // 此处略去 100 行    
     b.doSomething()    
     ...
 })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 虽然AMD也支持CMD的写法，同时还支持require作为依赖项传递，但RequireJS官方文档里默认上面的模块定义写法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AMD的API默认是一个当多个用，CMD的API严格区分，推崇职责单一。比如AMD里，require分全局require和局部require，都叫require。CMD里，没有全局require，而是根据模块系统的完备性，提供seajs.use来实现模块系统的加载启动。CMD里，每个API都简单纯粹。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/fullhouse/archive/2011/07/15/2107416.html&quot;&gt;什么是CommonJS？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.feeldesignstudio.com/2013/09/javascript-module-pattern-commonjs/&quot;&gt;JavaScript模块化开发（二）——CommonJS规范&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html&quot;&gt;浏览器加载 CommonJS 模块的原理与实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html&quot;&gt;Javascript模块化编程（二）：AMD规范&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/20351507&quot;&gt;AMD 和 CMD 的区别有哪些？- 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>JS跨域问题解决方式</title>
     <link href="http://korbinzhao.github.io/cross-origin-js"/>
     <updated>2015-10-23T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/cross-origin-js</id>
     <content type="html">&lt;p&gt;所谓跨域，或者异源，是指主机名（域名）、协议、端口号只要有其一不同，就为不同的域（或源）。浏览器中有一个基本的策略，叫同源策略，即限制“源”自A的脚本只能操作“同源”页面的DOM。以下列举几种跨域方式。&lt;/p&gt;

&lt;h2&gt;1.CORS&lt;/h2&gt;

&lt;p&gt;Cross-Origin Resource Sharing，跨域资源共享，简称 CORS。CORS系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。跨域资源共享是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。&lt;/p&gt;

&lt;p&gt;CORS(Cross-Origin Resource Sharing,􏰛源􏰉源共􏰠)是 W3C 的一个工作􏰡案,定义了在必须访问跨源资源时,浏览器与服􏰁务器应该如何􏰢沟通。CORS背􏰣后的基本思想,就是使用自定义的HTTP头部让浏览器与服􏰁务器进行沟􏰢通,从而决定请求或响应是应该成功,还是应该失败。&lt;/p&gt;

&lt;p&gt;具体如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个简单的使用GET或POST发􏰀的请求,它没有自定义的头部,而主体内容是text/plain。在发送􏰀该请求时,需要给它􏰤加一个􏰥额外的Origin头部,其中包含请求􏰝面的源信息(协􏰦议、域名和􏰧端口),以便服􏰁务器根据这个头部信息来决定是否给予响应。下面是 Origin 头部的一个示例:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 消费者发送一个Origin报头到提供者端：Origin: http://www.a.com；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;提供者发送一个Access-Control-Allow-Origin响应报头给消费者，如果值为“*”或Origin对应的站点，则表示同意共享资源给消费者，如果值为null或者不存在Access-Control-Allow-Origin报头，则表示不同意共享资源给消费者；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果没有这个头部,或者有这个头部但源信息不匹配,浏览器就会驳􏰩回请求。正常情况下,浏览器会处理请求&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;注：CORS支持GET/POST请求方式&lt;/p&gt;

&lt;h2&gt;2.JSONP&lt;/h2&gt;

&lt;p&gt;JSONP 是 JSON with padding(填充式 JSON 或参数式 JSON)的简写。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;callback({ &quot;name&quot;: &quot;Nicholas&quot; });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于一段JavaScript脚本来说，其“源”与它存储的地址无关，而取决于脚本被加载的页面，例如我们在页面中使用script引入存储在其他域的脚本文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://www.a.com/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里脚本与当前页面是同源的。除了script，还有img、iframe、link等都具有跨域加载资源的能力。&lt;/p&gt;

&lt;p&gt;Jsonp正是利用这种特性来实现跨域的：在页面中引入要跨域访问的来源，并定义回调函数处理跨域访问得到的json数据。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var script = document.createElement(&quot;script&quot;);
  script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;
  document.body.insertBefore(script, document.body.firstChild);

  function handleResponse(response){
    console.log(&quot;You are at IP address &quot; + response.ip + &quot;, which is in &quot; +
        response.city + &quot;, &quot; + response.region_name);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：JSONP只支持GET请求方式&lt;/p&gt;

&lt;h2&gt;3.修改document.domain来跨子域&lt;/h2&gt;

&lt;p&gt;www.a.com/1.html和a.com/2.html是不同域的，要使他们可以跨域访问，可通过修改document.domain来实现，即在两个页面中都设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.domain=&quot;a.com&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是document.domain只能往父级修改，如a.com改为www.a.com是不被允许的，这也是此方法的局限性，只使用于跨子域访问。&lt;/p&gt;

&lt;h2&gt;4.使用window.name来跨域访问&lt;/h2&gt;

&lt;p&gt;window.name是同一浏览器窗口下载入的所有页面共享的数据字段，所有窗口都可以读写此字段的内容。&lt;/p&gt;

&lt;p&gt;所以假设a.com要访问b.com的数据，只需要在b.com中将数据放在window.name中，然后a.com从中取出即可。此方法适用于像iframe这样的嵌套页面架构。&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000003784372&quot;&gt;浅谈js跨域问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;JavaScript高级程序设计&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>入职了，转正了</title>
     <link href="http://korbinzhao.github.io/become-a-regular-worker"/>
     <updated>2015-10-23T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/become-a-regular-worker</id>
     <content type="html">&lt;p&gt;正式入职3个月，经过了转正面试，接连有了两次转正后的交流会。今晚这次交流比较有感触，所以特别记一下。&lt;/p&gt;

&lt;p&gt;前两天，团队新近的6个新人全部转正面试结束。老板ZY把我们同组的6个人叫到一起，开了个简单的交流会。此前的转正面试加上最近2次交流会，有一些收获，记录一下，给以后工作中的自己提个醒。&lt;/p&gt;

&lt;h2&gt;从业务中抽离出来做些自己的事情&lt;/h2&gt;

&lt;p&gt;我们的日常业务是很忙的。要学会从繁重的业务中抽身出来，去做些个人成长、技术成长的事情。说白了，只做业务的话说实话，最后只是简单一些重复劳动，如果不能自己抽出时间进行学习、积累的话，自己很难会有成长，对于之后的KPI考核、薪酬、晋升其实是没有什么好处的。&lt;/p&gt;

&lt;p&gt;这一点是自从入职后，每次开交流会团队老大YX和HR都会返回强调的。只做业务，没有自己的核心竞争力的话，个人的不可替代性就太强了，对于团队的价值就非常小。&lt;/p&gt;

&lt;h2&gt;工作中思考&lt;/h2&gt;

&lt;p&gt;思考是工作中非常重要的一个能力，不能在工作中有自己的思考，那么你就只能是别人眼中的一个工具。这里的思考既有对前端团队内部效率、工具的思考，也有对自己所负责业务的思考。&lt;/p&gt;

&lt;h2&gt;将自己的思考写出来&lt;/h2&gt;

&lt;p&gt;一些事情自己能想到以及想清楚和真正把想法写出来是完全两种不同的概念。很多时候，我们只是自我感觉把有些东西想清楚了，但是真的当我们需要临场表达的时候常常是毫无逻辑、丢三落四或者混乱不堪的。这说明我们还没有把自己的思路真正的理清楚。那么，平时自己有所思考的时候，把自己的想法写出来吧！&lt;/p&gt;

&lt;p&gt;写作可以让你对自己的过往的思考有一个清晰的回顾和整理，并且当我们回过头来看自己的过往的想法时也是一种意义非法的事情。&lt;/p&gt;

&lt;h2&gt;拓展自己的舒服边界-团队中的充分交流&lt;/h2&gt;

&lt;p&gt;作为一个资深的、被很多人认为很内向的人，在面对长辈和领导时总是会有一种莫名的紧张，会表现的很内向，这个毛病伴随了我20+年。&lt;/p&gt;

&lt;p&gt;要解决这个问题，用今天ZY的一句话来说，就是要拓展自己的舒服边界。每个人都有自己的舒服边界，有的人舒服边界大一些，则表现出来就外向一点，有的人舒服边界小一些，则表现出来就内向一点。&lt;/p&gt;

&lt;p&gt;没办法，平时不能太懒，要多花点时间和团队其他成员交流。&lt;/p&gt;

&lt;p&gt;能想到的一个比较好的方式，&lt;strong&gt;就是在自己迟疑要不要说某句话或者和某人交流的时候，放弃迟疑，果断迈出第一步吧。&lt;/strong&gt;改变是一点点发生的。&lt;/p&gt;

&lt;h2&gt;将自己的实力充分表现出来&lt;/h2&gt;

&lt;p&gt;最后一点感触很深的是，无论你多牛掰，不表现出来，不让你身边的人、老版、HR看到，一切都是白搭的。所以工作中很苦逼的一种状态会是，你每天累得像孙子一样，老板却看不到你的实力、成果。&lt;/p&gt;

&lt;p&gt;所以，适时的把自己的实力、观点表达出来吧~&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Mac OS X 快捷键</title>
     <link href="http://korbinzhao.github.io/mac-os-x-shortcut"/>
     <updated>2015-08-23T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/mac-os-x-shortcut</id>
     <content type="html">&lt;p&gt;Mac OS X 的快捷键会有效提升我们的办公效率，下面是常用的部分快捷键的汇总，并在文章的最后附有详细的系列学习视频&lt;/p&gt;

&lt;p&gt;command+H : 隐藏该程序&lt;/p&gt;

&lt;p&gt;command＋option＋H: 隐藏当前应用外的其它所有应用&lt;/p&gt;

&lt;p&gt;command+, : 呼出应用程序设置&lt;/p&gt;

&lt;p&gt;command+option+v : 剪切&lt;/p&gt;

&lt;p&gt;command+delete: 移到废纸篓&lt;/p&gt;

&lt;p&gt;command+i : 显示简介&lt;/p&gt;

&lt;p&gt;command＋option＋i：查看选中的多个文件的简介&lt;/p&gt;

&lt;p&gt;command+上/下 : 跳到顶部底部&lt;/p&gt;

&lt;p&gt;command＋前／后： 跳到行首行尾&lt;/p&gt;

&lt;p&gt;command＋option＋shift＋v：只粘贴文本，不粘贴样式&lt;/p&gt;

&lt;p&gt;fn+delete: 向后删除&lt;/p&gt;

&lt;p&gt;拖动文件：剪切&lt;/p&gt;

&lt;p&gt;option＋拖动文件：复制&lt;/p&gt;

&lt;p&gt;选中+space（或三指点击触控板） ： 预览&lt;/p&gt;

&lt;p&gt;选中多个文件＋右键 ： 新建文件夹并将选中文件放进去&lt;/p&gt;

&lt;p&gt;在显示简介中修改默认文件打开方式&lt;/p&gt;

&lt;p&gt;四指向上推，呼出MissionControl，按住option添加桌面，四指左右滑动（或command+左/右），切换
桌面&lt;/p&gt;

&lt;p&gt;四指下滑，展示当前应用的所有打开窗口&lt;/p&gt;

&lt;p&gt;在英文输入法状态下长按韵母字母，就可以呼出带有声调的字母符号&lt;/p&gt;

&lt;p&gt;－－－－－－－－－－－－－－－－－－－－－－&lt;/p&gt;

&lt;p&gt;推荐的学习视频：&lt;a href=&quot;http://www.youku.com/playlist_show/id_18654878.html&quot;&gt;深入浅出 Mac OSX 中文教程&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>nodejs+mongdb+express建站学习中所踩得坑</title>
     <link href="http://korbinzhao.github.io/nodejs-express-mongodb-website"/>
     <updated>2015-06-02T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/nodejs-express-mongodb-website</id>
     <content type="html">&lt;h2&gt;网站开发框架&lt;/h2&gt;

&lt;p&gt;在网站开发之前，我们首先对网站开发框架进行设计。主要分为后端、前端、本地开发环境三部分。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;网站后端由nodejs支撑，同时安装nodejs框架express，数据库选择mongodb，同时选择对mongodb进行快速建模的工具mongoose，后端模板引擎选择jade，日期和时间的格式化选择moment.js，express、mongoose、jade、moment.js都通过npm模块安装包来安装。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端选择jQuery类库、Bootstrap样式框架，jQuery和Bootstrap都属于前端静态资源，使用Bower来安装它们，Bower也是一个npm安装模块，因此也需要使用npm安装。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本地开发环境用到less的编译、cssmin样式合并、JSHint前后端单元测试的实现等。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;img src=&quot;/images/nodejs-express-mongondb-website/website-framework.png&quot; title=&quot;website framework&quot; alt=&quot;website framework&quot; /&gt;&lt;/p&gt;

&lt;p&gt;视频教程详见&lt;a href=&quot;http://www.imooc.com/learn/75&quot; title=&quot;imooc.com&quot;&gt;imooc.com&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;nodejs的安装&lt;/h2&gt;

&lt;p&gt;开发前需要先安装[nodejs]，通过nodejs官网即可完成nodejs的安装。&lt;/p&gt;

&lt;h2&gt;mongodb的安装&lt;/h2&gt;

&lt;p&gt;mongodb是一个高性能、开源、无模式的文档型数据库（非关系型数据库），是当前NoSql数据库中比较热门的一种。mongodb中的一条记录就是一个文档（document），它的数据结构由键值对组成。mongodb文档和JSON对象很相似。&lt;/p&gt;

&lt;p&gt;拓展：NoSql，全称是Not Only Sql，指的是非关系型数据库。下一代数据库主要解决几个要点：非关系型、分布式、开源、水平可拓展。&lt;/p&gt;

&lt;p&gt;开发前mongodb需要单独安装。这也是我在不了解情况下踩过的一个坑，mongoose是mongodb的快速建模工具，通过npm安装mongoose并不会同时安装mongodb，且在安装完成mongobd后，在运行node app.&lt;/p&gt;

&lt;p&gt;首先安装&lt;a href=&quot;https://www.mongodb.org/&quot; title=&quot;mongodb&quot;&gt;mongodb&lt;/a&gt;,js本地查看网站效果前，必须前行启动mongodb，并与node连接起来。在项目文件夹imooc下新建data文件夹用于存放mongdb数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd d:/fe_exercise/imooc
mkdir data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入mongodb的安装目录 D:\Program Files\MongoDB 2.6 Standard下的bin文件夹中执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd d:/Program Files/MongoDB 2.6 Standard/bin
mongod --dbpath &quot;d:/fe_exercise/imooc/data&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现以下结果则证明连接成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/nodejs-express-mongondb-website/mongodb-node-link.png&quot; title=&quot;mongodb-node-link&quot; alt=&quot;mongodb-node-link&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每次本地查看网站前，用命令行启动mongodb，并将mongodb和node连接是一件很麻烦的事情。可以通过一种相对简单方法可以简化这个过程。具体方法如下：&lt;/p&gt;

&lt;p&gt;新建一个名为mongodb.cmd的文件，文件内容如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:: 定位到D盘
d:
:: 切换到mongodb的数据库目录
cd Program files\MongoDB 2.6 Standard\data
:: 删除数据库锁定记录文件
if exist mongod.lock del mongod.lock missing
:: 切换到mongodb的bin目录
cd ..\bin
:: 配置mongodb的文档存储目录
mongod --dbpath &quot;D:\fe_exercise\imooc\data&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;双击运行，即可完成启动mongodb，连接mongodb和node的过程。&lt;/p&gt;

&lt;h2&gt;mongodb可视化管理工具：rockmongo的安装与配置&lt;/h2&gt;

&lt;p&gt;rockmongo是一个用PHP5写的mongodb可视化管理工具。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下载rockmongo&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://rockmongo.com/downloads&quot; title=&quot;rockmongo&quot;&gt;rockmongo官网&lt;/a&gt;目前无法访问，可选择另一种替代方式：直接访问&lt;a href=&quot;https://github.com/iwind/rockmongo&quot; title=&quot;rockmongo&quot;&gt;rockmongo github地址&lt;/a&gt;，选择一个版本进行下载，本文选用1.1.7版本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装PHP环境&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;rockmongo的运行需要PHP环境，本文选用&lt;a href=&quot;http://pan.baidu.com/s/1c0dInYg&quot; title=&quot;appserv&quot;&gt;AppServ 2.5.1&lt;/a&gt;进行PHP、Apache等环境的打包安装，AppServ是PHP网页架站工具组合包，所包含的软件有：Apache、Apache Monitor、MySQL、PHPMyAdmin等。AppServ 2.5.1中PHP版本为PHP 5.2。下载AppServ点击安装，本文选用安装目录为C:/AppServ。&lt;/p&gt;

&lt;p&gt;将上文中从github上下载的rockmongo 1.1.7文件夹重命名为rockmongo，放到AppServ安装目录下的www文件夹中：C:/AppServ/www。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下载mongodb-php拓展&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据所安装的PHP版本选择相应的mongo-php驱动拓展，本文PHP版本为5.2，因此选择PHP 5.2 VC6 Thread-Safe Mongo extension：&lt;a href=&quot;http://pan.baidu.com/s/1eQo33kI&quot; title=&quot;mongo-php-driver&quot;&gt;mongo-php-driver&lt;/a&gt;，将下载目录中的php_mongo.dll文件copy到C:/AppServ/php5/ext中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;修改php.ini文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在php.ini文件中添加extension=php_mongo.dll&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重启Apache服务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;重启Apache服务&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;修改rockmongo中的文件config..php&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置以下内容的USERNAME和PASSWORD，将两者均设为root&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$MONGO[&quot;servers&quot;][$i][&quot;control_users&quot;][&quot;root&quot;] = &quot;root&quot;;//one of control users [&quot;USERNAME&quot;]=PASSWORD, works only if mongo_auth=false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用rockmongo登录mongodb&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;访问http://localhost/rockmongo,界面如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/nodejs-express-mongondb-website/login.png&quot; title=&quot;login&quot; alt=&quot;login&quot; /&gt;&lt;/p&gt;

&lt;p&gt;登录后界面如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/nodejs-express-mongondb-website/dbview.png&quot; title=&quot;dbview&quot; alt=&quot;dbview&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;项目结构的初始化&lt;/h2&gt;

&lt;p&gt;进入项目目录，运行Node.js command prompt,运行以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- imooc/
 &amp;gt; npm install express
 &amp;gt; npm install jade
 &amp;gt; npm install mongoose
 &amp;gt; npm install bower -g
 &amp;gt; npm install bootstrap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过npm对项目中使用的框架和模块进行安装之后就可以正式开始项目开发了。具体项目源码见&lt;a href=&quot;https://github.com/korbinzhao/exercise/tree/master/imooc&quot; title=&quot;imooc github&quot;&gt;github仓库&lt;/a&gt;。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>SVG入门</title>
     <link href="http://korbinzhao.github.io/introduction-to-svg"/>
     <updated>2015-06-02T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/introduction-to-svg</id>
     <content type="html">&lt;h2&gt;SVG&lt;/h2&gt;

&lt;p&gt;SVG是使用XML描述的矢量文件，全称可缩放矢量图形，用于描述二维矢量图形的一种图形格式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;位图&amp;amp;矢量图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;位图（BMP、PNG、JPG等）是基于颜色的描述，由一个个像素点组成；矢量图（SVG、AI等）是基于数学的描述，根据几何特征来绘制图形，矢量可以是一个点或一条线，矢量图只能靠软件生成，特点是放大后图像不会失真，和分辨率无关。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/introduction-to-svg/svg.png&quot; title=&quot;svg&quot; alt=&quot;svg&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;SVG示例&lt;/h2&gt;

&lt;p&gt;simple.svg&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;200&quot; height=&quot;200&quot;&amp;gt;
&amp;lt;!--face--&amp;gt;
&amp;lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;90&quot; fill=&quot;#39F&quot;/&amp;gt;
&amp;lt;!--eyes--&amp;gt;
&amp;lt;circle cx=&quot;70&quot; cy=&quot;80&quot; r=&quot;20&quot; fill=&quot;white&quot;/&amp;gt;
&amp;lt;circle cx=&quot;130&quot; cy=&quot;80&quot; r=&quot;20&quot; fill=&quot;white&quot;/&amp;gt;
&amp;lt;circle cx=&quot;65&quot; cy=&quot;75&quot; r=&quot;10&quot; fill=&quot;black&quot;/&amp;gt;
&amp;lt;circle cx=&quot;125&quot; cy=&quot;75&quot; r=&quot;10&quot; fill=&quot;black&quot;/&amp;gt;
&amp;lt;!--smile--&amp;gt;
&amp;lt;path d=&quot;M 50 140 A 60 60 0 0 0 150 140&quot; stroke=&quot;white&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&amp;gt;
&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;SVG的使用方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;浏览器直接打开&lt;/li&gt;
&lt;li&gt;在HTML中使用img标签引用&lt;/li&gt;
&lt;li&gt;直接在HTML中使用SVG&lt;/li&gt;
&lt;li&gt;作为CSS背景&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;基本操作API&lt;/h2&gt;

&lt;p&gt;创建图形，需要使用document.createElementNS()方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.createElementNS(ns, tagName)
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>关于方法</title>
     <link href="http://korbinzhao.github.io/about-method"/>
     <updated>2014-12-05T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/about-method</id>
     <content type="html">&lt;p&gt;有时候我们每天忙忙碌碌只是为了让自己觉得自己很努力，其实在徒然做着无用功。&lt;/p&gt;

&lt;h2&gt;装作努力，只是一种心理慰藉&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;现象：&lt;/strong&gt;我们时长会有这种感觉：每天忙忙碌碌却又不知道自己忙了什么，或是看不到忙碌的效果。这个时候我们可能就已经陷入了自我安慰、自我欺骗的陷阱。也就是说我们不自觉得伪装成很忙的样子，只是为了让自己觉得自己每天都很努力，寻求一种心理慰藉，实际上我们每天所做的事情只是些对自己目标实现没有太大意义的无用功。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原因：&lt;/strong&gt;为什么会产生这种状态呢？我觉得产生这种状态的心理和拖延症产生的心理是类似的，当我们做一件自己不愿意做的事情时就会产生一种疲惫感，拖延就是因为畏惧这种疲惫感而产生的逃避；同理，当我们被迫开始做这件不愿意做的事情时，我们也会经意不经意地去用一种方式继续逃避，比如漫不经心的草草了事或者刚开始几分钟注意力就转移到了其他事情上去。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;举例：&lt;/strong&gt;以我为例，对于作为音乐白痴+五音不全的自己来说，唱K一直对我都是一件很不情愿的事情，因为没有一两首自己拿手的歌，所以每次去KTV唱与不唱歌对我来说都是一件很尴尬的事情。但是唱K确实又是一种必备的社交手段，无论对生活还是工作都是很有好处而且必须掌握的。尽管自己也很想能够唱的几首好歌，但是几乎每次尝试都是以中途开原唱，然后草草应付了事。&lt;/p&gt;

&lt;h2&gt;做事没有捷径，却有方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;做事情前先明确做事的方法。&lt;/strong&gt;做每件事情都会有相应的方法，这些方法肯定不会是一成不变的宝典，却是很多前人经验和技巧的总结。因此，做事情先明确做事的方法，往往可以达到事半功倍的效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;举例1：&lt;/strong&gt;比如《金字塔原理》这本书建议我们写作、表达应该遵循金字塔原理，文章中所有思想的理想组织结构也就必定是一个金字塔结构——由一个总的思想统领多组思想。这种结构用程序员熟悉的数据结构来表述，其实就是树形结构。这种结构清晰明了，一目了然，便于理解，不会让读者或者听众无法抓取你表达的结构和重点。&lt;/p&gt;

&lt;p&gt;因此，我现在也开始用上述方式开始组织自己的思维和文字。在平时阅读文章的经验来看，很多作者文章并没有清晰的结构，段落没有中心句，也没有适当的加粗。这就使得阅读此类文章更加费神。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;举例2：&lt;/strong&gt;再说回前文中唱K的例子，受到《金字塔原理》的影响，我也开始寻找拯救我唱K窘境的方法。此时，我想起上小学4年级时数学老师教我们唱歌的场景（说来惭愧，小学条件有限，连个音乐课都没有），当时的学习是老师教一句，我们跟着学一句。五音不全，毫无旋律感的自己居然现在还能清晰记得那首歌的旋律。于是我给自己制定了使用这种最简单方式每天学习一首歌的计划，已经坚持了三天，初见成效。&lt;/p&gt;

&lt;p&gt;具体方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;以一段歌词为单位，一句一句学习，先跟唱，再自己唱，有不对的地方及时纠正。这一段没有问题之后，再跳到下一段学习。&lt;/li&gt;
&lt;li&gt;完成所有歌词学习后，完整唱几遍，查漏补缺。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这其实是再简单不过的方法了，但是当我们面对复杂场景或是复杂问题时，再加上一些情绪化的问题，往往将自己绕进某种恶性循环中，长时间跳不出来。&lt;/p&gt;

&lt;h2&gt;最后的话&lt;/h2&gt;

&lt;p&gt;写这篇文章的原因是希望自己能够将最近的经历和思考总结一下，时刻提醒自己不要陷入自我慰藉的坑中，并且对一些重要的事情能够找到有效的方法，让自己每天的忙碌不要成为无用功。也希望能够给大家提供一些借鉴。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>关于思考</title>
     <link href="http://korbinzhao.github.io/about-thinking"/>
     <updated>2014-11-21T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/about-thinking</id>
     <content type="html">&lt;p&gt;这两天世界互联网大会在乌镇热热闹闹开起来了，国内互联网大佬云集，看了两场分享，激起自己的一些思考。&lt;/p&gt;

&lt;h2&gt;关于演讲&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;演讲能力是职场乃至人生之中非常重要的能力，无论从事技术还是管理岗位。&lt;/strong&gt;今天看了场马云关于跨境电子商务的演讲，侃侃而谈40分钟。中国互联网界比较能言善辩的除了周鸿祎也就是马云了。演讲前半段还是有很多干货的，确实对我产生了很大冲击，用舍友的话说这演讲很有煽动力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;成功的演讲必须言之有物、逻辑清晰、声情并茂。&lt;/strong&gt;之前一直希望能够通过演讲课培训的方式有效提升自己的演讲能力。现在越发觉得优秀的演讲必须言之有物，想要言之有物，就必须保证演讲的内容是你自己真正思考过的东西，并且能够保证有一个清晰明了的框架将内容撑起来。当你所说的内容是你真正认同的经过自己思考的内容之后，所谓的一些抑扬顿挫、声情并茂、眼神交流等演讲技巧就会很自然的充斥在你的演讲中。所以我觉得周鸿祎、马云之所以有很好的演讲能力，无非是说的内容是自己每天思考、每天和别人交流的想法罢了。&lt;/p&gt;

&lt;h2&gt;关于视野&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;视野，就是对于未来的清晰的判断。&lt;/strong&gt;马云在这次演讲中开篇就讲了眼光（vision）的重要性。不过我个人更喜欢把vision翻译成视野。所谓视野，我的理解是对于未来有一个属于自己清晰的判断。“如果你想今天做，明天就成功，这种机会几乎是不存在的。因为聪明的人实在太多了，比聪明、比勤奋都是没有机会的。只有比对未来的判断，并且提早准备才有可能成功。正如阿里现在的状态是15年前就想到并且开始做的。”“战略就是你认为这样走下去，将来一定会到那儿。提早准备。”马云如是说。可见持续思考未来，对未来进行清晰判断的重要性。&lt;/p&gt;

&lt;h2&gt;关于思考&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;停止思考，便陷入颓废。&lt;/strong&gt;安逸的生活是舒服的，但长久的安逸便成了颓废，会让你失去斗志，停步不前，长久下去便失去了价值，失去立足社会的基础。颓废的一大标志便是不愿意去深入思考，毕竟每天接触到的信息实在太大，无论是新闻客户端推送的长篇累牍的新闻、无休无止的QQ群、微信群消息。。信息爆炸造成神经疲劳，造成厌倦，大量信息一扫而过，其实根本没有有效接收。造成这种状态的原因一个是接收信息毫无目的，另一个便是没有将长久以来接收的信息进行有效梳理、深入思考。这就造成了每天浏览大量信息，却也只是徒然做些无用功。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;设计框架，清晰梳理，深入思考。&lt;/strong&gt;为了能够让自己每天有所成长，不再颓废，我能想到的方式便是每天有目标的接收信息，并且设计框架，进行梳理，继而深入思考。比如对于FE和PM两方面的信息进行有目标的接收，根据各自的特点、内在联系设计分类和逻辑框架，将每天积累的内容进行填充，继而根据梳理进行进一步思考。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;思考一个问题：有什么，要什么，放弃什么。&lt;/strong&gt;在中外互联网领袖高峰对话上，李彦宏说自己每天比较头疼的便是机会太多，每天5点钟便会起床思考到底该放弃那些机会。比较有趣的是，马云在后面打趣的补充到，如果你想清楚“自己有什么，要什么，放弃什么”这个问题，其实摆在你面前的机会真的很少。所以自己真正想要的是什么，这个问题每个人都有必要好好思考，想清楚了，也许就没那么多迷茫了。&lt;/p&gt;

&lt;h2&gt;关于成功&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;和优秀的人为伍。&lt;/strong&gt;提到成功，立马用到眼前的让人颇感厌烦的成功学。想想也是我们之前对成功的定义过于狭隘了。我眼中的成功应该是按照自己想要的生活方式快乐的生活。不过如果真的这样定义的话，我离自己想要的成功还真是相差甚远。目前的状态既不是自己想要的生活方式，自己也没那么快乐。不过想想自己真正快乐的时候，其实是和自己或喜欢或欣赏的人在一起的时光，这样的人充满正能量、总是给你带来快乐，甚至充满激情，对某些事物有自己的想法，并且更难能可贵的是有自己的态度和坚持。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;团队比idea要重要。&lt;/strong&gt;突然想到创业导师徐小平的一句话：“初创团队，合伙人比商业模式更重要。”非常认同，正如投资大师巴菲特的投资其实只看人一样，人靠谱的话，其实这个人做什么都是会成功的。希望自己日后能够足够幸运遇到那么一帮让我佩服、足够靠谱的人，共同做点事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;成功不可复制，失败或可避免。&lt;/strong&gt;吴晓波最近推出的个人脱口秀节目《吴晓波频道》中有一句话：“成功不可复制，失败或可避免。”这个观点再次被马云印证，马云在演讲中说其实失败的道理差不多，如果能把其他人失败的事情研究的差不多，就离成功不远了。&lt;/p&gt;

&lt;h2&gt;最后的自勉&lt;/h2&gt;

&lt;p&gt;最后拿三句话做自勉吧！&lt;/p&gt;

&lt;p&gt;前两句是马云的，后一句是自己的。&lt;/p&gt;

&lt;p&gt;“对未来执着；有优秀团队；不怕犯错。那么总有一天你会成功。”&lt;/p&gt;

&lt;p&gt;“自信来自于你知道自己要做什么。”&lt;/p&gt;

&lt;p&gt;“每天用自己最充沛的精力，做有价值的事情。”&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Cocos2d-X 3.0 事件分发机制</title>
     <link href="http://korbinzhao.github.io/cocos2d-event-dispatcher"/>
     <updated>2014-11-15T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/cocos2d-event-dispatcher</id>
     <content type="html">&lt;h2&gt;事件&lt;/h2&gt;

&lt;p&gt;Cocos2d-JS v3.x中事件分发机制进行了重写，事件可以与任意对象绑定，而不是只有Layer才能获取。对象创建自己的事件监听器，然后加入到全局的事件管理器统一管理。&lt;/p&gt;

&lt;p&gt;事件监听器有以下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;触摸事件&lt;/li&gt;
&lt;li&gt;键盘响应事件&lt;/li&gt;
&lt;li&gt;鼠标响应事件&lt;/li&gt;
&lt;li&gt;自定义事件&lt;/li&gt;
&lt;li&gt;加速计事件&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;事件分发&lt;/h2&gt;

&lt;p&gt;在了解事件分发机制之前，我们首先要明确什么是事件分发。&lt;/p&gt;

&lt;p&gt;对于事件分发，cocos2d官方定义为：当事件发生(例如，用户触摸屏幕，或者敲键盘)，EventDispatcher 会发布(Event objects)事件对象到合适的EventListeners，并调用你的回调。各个Event object包含事件的信息(比如，触摸点所在的坐标)。&lt;/p&gt;

&lt;p&gt;我的理解是对于一个事件（比如触摸事件、键盘相应事件等）可以与任意对象绑定，那么当这个事件被用户触发时，此时应该执行哪一个对象的回调函数（比如此时我们在好几个sprite上同时绑定了touch事件，用户此时点击屏幕，用户此时想点击的到底是哪一个sprite），我们就需要作出判断。EventDispatcher做的就是这个事情。&lt;/p&gt;

&lt;p&gt;以touch事件（触摸事件）为例，判断用户点击的是哪一个sprite的方法很简单，其实就是在onTouchBegan方法中获取点击点的坐标pos,然后通过cc.rectContainsPoint(target.getBoundingBox(),pos)判断点击的点是否在SushiSprite上。不过此时又会出现另外一个问题，就是如果两个sprite有相互重叠的部分，而此时用户点击的恰恰是重叠部分，那么怎么判断到底点击的是哪一个sprite呢？这里是通过priority（分为两种：SceneGraphPriority和FixedPriority）来解决的，优先级高的sprite优先执行它所对应的事件监听器的回调函数。这样就形成了一个按照优先级高低排列的sprite队列等待依次执行用户触发的事件，而这中间则通过swallowTouches（吞没事件）属性来控制是否继续向优先级低的sprite传递事件。这就形成了一个完整的事件分发机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;tip:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SceneGraphPriority(显示优先级)：根据屏幕显示的“遮盖”实际情况，进行有序的函数回调。zOrder越大，优先级越大。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FixedPriority(固定优先级)：依据手动设定的 Priority 值来决定事件相应的优先级，值越小优先级越高&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;总结一下：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;通过点击位置进行点击范围判断，来确定执行哪一个sprite的事件监听器&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果该位置存在重叠的sprite绑定了相同的事件，则依据优先级（SceneGraphPriority显示优先级或FixedPriority固定优先级）来顺序执行函数回调&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过设置swallowTouches属性为true，并在onTouchBegan中返回true或者false来决定是否阻止事件的顺序传递。如果onTouchBegan返回true，且swallowTouches为true，则事件被吞没，事件的顺序传递则被阻止。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;实例&lt;/h2&gt;

&lt;p&gt;新建一个sprite，并为其添加一个touch事件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var SushiSprite = cc.Sprite.extend({
    onEnter:function () {
        cc.log(&quot;onEnter&quot;);
        this._super();
    },

    onExit:function () {
        cc.log(&quot;onExit&quot;);
    }
});

addTouchEventListenser:function(){
    this.touchListener = cc.EventListener.create({
        event: cc.EventListener.TOUCH_ONE_BY_ONE,
        // When &quot;swallow touches&quot; is true, then returning &#39;true&#39; from the onTouchBegan method will &quot;swallow&quot; the touch event, preventing other listeners from using it.
        swallowTouches: true,
        //onTouchBegan event callback function                      
        onTouchBegan: function (touch, event) { 
            var pos = touch.getLocation();
            var target = event.getCurrentTarget();  
            if ( cc.rectContainsPoint(target.getBoundingBox(),pos)) {
                cc.log(&quot;touched&quot;)
                return true;
            }
            return false;
        }
    cc.eventManager.addListener(this.touchListener,this);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的代码：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先通过使用cc.EventListener.create创建了一个Touch事件监听器touchListener&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;然后，通过cc.eventManager.addListener注册监听器到事件管理器。cc.EventListener.create扩展出一个用户监听器。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;event属性，定义这个监听器监听的类型。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;swallowTouches属性设置是否吃掉事件，事件被吃掉后不会递给下一层监听器。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;onTouchBegan方法处理触摸点击按下事件，我们在这里可以获取到触摸点的坐标pos。event.getCurrentTarget()获取当前事件的接受者，并判断当前的是否点击到了SushiSprite。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在touch事件中，我们还可以添加onTouchMoved/onTouchEnded方法监听touch移动和结束的回调。如果onTouchBegan返回false后onTouchMoved/onTouchEnded不会执行。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;tip: 在onTouchBegan方法中获取点击点的坐标pos,然后通过cc.rectContainsPoint(target.getBoundingBox(),pos)判断点击的点是否在SushiSprite上。&lt;/p&gt;

&lt;h2&gt;参考文献&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://cn.cocos2d-x.org/article/index?type=cocos2d-x&amp;amp;url=/doc/cocos-docs-master/manual/framework/cocos2d-js/3-jumping-into-cocos2d-js/3-6-creating-user-interaction-with-event-manager/zh.md&quot;&gt;[1] http://cn.cocos2d-x.org/article/index?type=cocos2d-x&amp;amp;url=/doc/cocos-docs-master/manual/framework/cocos2d-js/3-jumping-into-cocos2d-js/3-6-creating-user-interaction-with-event-manager/zh.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://cn.cocos2d-x.org/article/index?type=wiki&amp;amp;url=/doc/cocos-docs-master/manual/framework/native/wiki/eventdispatcher-mechanism/zh.md&quot;&gt;[2] http://cn.cocos2d-x.org/article/index?type=wiki&amp;amp;url=/doc/cocos-docs-master/manual/framework/native/wiki/eventdispatcher-mechanism/zh.md&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
