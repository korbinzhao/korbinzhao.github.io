<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>Joebon's world</title>
   <link href="http://joebon.cc/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://joebon.cc" rel="alternate" type="text/html" />
   <updated>2015-11-16T00:21:19+08:00</updated>
   <id>http://joebon.cc</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>和PD、运营、设计师和用研们的一顿饭</title>
     <link href="http://korbinzhao.github.io/a-meal-with-colleagues"/>
     <updated>2015-11-16T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/a-meal-with-colleagues</id>
     <content type="html">&lt;p&gt;受PD的邀请，今晚一帮同事去她家做客。去之前，其实心里很是忐忑，自己面对一帮陌生人总会多多少少有些逃避的心理。但是理智告诉我，还是必须得去的，虽然平时工作很忙，经常陷入某个难缠的bug好久，让自己越发的有些寡言少语。一来这不是我想要的状态，二来长此以往是非常不健康的。&lt;/p&gt;

&lt;h2&gt;经过&lt;/h2&gt;

&lt;p&gt;去之前买了点水果带过去，否则空着手去做客太说不过去了。幸好买了，其实大家过去也都多多少少带了些东西，比如水果、红酒。PD家离我住的地方倒也非常近，打了车5分钟就到小区门口了，从小区门口进去一直走，穿过漆黑一片的小路，最近好不容易找到PD的家。&lt;/p&gt;

&lt;p&gt;小区配套挺差的，连个路灯都没开，附近可以吃饭消遣的地方看起来也不多。但是，已进入房间，顿时眼前一亮，装修不同，真的可以给同样的房子带来完全不同的感觉。超大的客厅（把原来的客厅和一个卧室打通连在一起），客厅中间放着沙发、对面是超大的电视屏幕，后面是一张很大的工作长桌，客人多的时候可以用来当做餐桌（当然，这次就是这样做的），房间内到处都是简约却充满文艺气息的装饰品，房子位于顶楼，复式结构，二楼虽然只是楼顶屋檐下面的一点空间，但是布局合理，丝毫没有压抑的感觉，而且还有2个天窗，天气好的时候抬头就可以看到星星。一句话总结，这房子完全像是设计师精心设计过的房子，但是事实上只是房子的主人——另一个PD的设计，果然是一个充满设计师气质的PD。&lt;/p&gt;

&lt;p&gt;晚饭完全有一个帅帅的运营下厨，扬州人，之前还合作过，其实想说我和扬州还有些渊源，后来忍住没说。最后7点半，前前后后到了有十来个人。晚餐超级丰盛，三文鱼、酸菜鱼、蒜蓉油虾、香橙鸡肉沙拉、啤酒红烧肉、红焖茄子、蒜炒白菜、毛豆米、拍黄瓜、焗海蟹、烤鸡翅、各种糕点。。。我只想说城里人真会吃。还没开始吃饭，下厨的运营就开了一瓶红酒，其他人根据自己喜好选择红酒、果汁。席间还尝试了“peng”一下的喝法，就是用一种叫不出名字的国外的白酒兑上雪碧，手掌按住杯口，往桌子上猛地一按，“peng”的一下，然后往酒里撒点盐，一饮而尽。第一次尝试这种喝法，还挺爽的。&lt;/p&gt;

&lt;h2&gt;感想&lt;/h2&gt;

&lt;p&gt;其实呢，之所有有冲动把简单的一顿饭写出来，就是想谈谈感受。在技术团队待久了，每天对着电脑敲代码，需要说话的场景不是很多，再加上技术团队整体在性格上会比较沉闷，在生活品质和乐趣上的追求也没有其他团队那么多。让我这段时间总感觉有些无聊，心情莫名低落，即使好不容易有点时间也宁愿宅着，有一种非常懒散拖延的状态。这种状态于工作、于生活都不是太好的。所以这里提醒下自己，多走出去，多和不同背景、不同岗位的人交流，这不仅有利于拓宽自己的视野，也会让自己更开心一点。正如今天的这次简单的聚会，虽然去之前略感忐忑，去之后却感觉很享受这个过程，每个人仿佛都有着自己独特的故事、自己独特的生活乐趣，这也是我想经历和正在追求的。&lt;/p&gt;

&lt;p&gt;另外，和有趣的人一起，你也会变得有趣。现在的我有点太无聊了，自己都受不了自己。我需要和有趣的人在一起。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Date对象的浏览器兼容性问题</title>
     <link href="http://korbinzhao.github.io/date-cross-browser-safari-chrome"/>
     <updated>2015-11-06T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/date-cross-browser-safari-chrome</id>
     <content type="html">&lt;h2&gt;new Date()、Date.parse()方法在浏览器中的兼容性问题&lt;/h2&gt;

&lt;p&gt;   Date在不同浏览器中对于传入的时间字符串的格式要求是不一样的。比如在chrome浏览器的控制台中输入以下内容，会得到相应结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Date.parse(&#39;2015-11-11 00:00:00&#39;)
//-&amp;gt;1447171200000
Date.parse(&#39;2015/11/11 00:00:00&#39;)
//-&amp;gt;1447171200000
new Date(&#39;2015-11-11 00:00:00&#39;)
//-&amp;gt;Wed Nov 11 2015 00:00:00 GMT+0800 (CST)
new Date(&#39;2015/11/11 00:00:00&#39;)
//-&amp;gt;Wed Nov 11 2015 00:00:00 GMT+0800 (CST)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  可以发现，chrome对于&#39;-&#39;和&#39;/&#39;分割日期的形式都是支持的，能够返回正确的毫秒数或者时间格式。&lt;/p&gt;

&lt;p&gt;  下面在safari浏览器中输入相同内容，查看对应结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Date.parse(&#39;2015-11-11 00:00:00&#39;)
&amp;lt; NaN = $1
&amp;gt; Date.parse(&#39;2015/11/11 00:00:00&#39;)
&amp;lt; 1447171200000 = $2
&amp;gt; new Date(&#39;2015-11-11 00:00:00&#39;)
&amp;lt; Invalid Date = $3
&amp;gt; new Date(&#39;2015/11/11 00:00:00&#39;)
&amp;lt; Wed Nov 11 2015 00:00:00 GMT+0800 (CST) = $4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   可以发现，safari仅对&#39;/&#39;分割日期的形式支持，对&#39;-&#39;分割日期的形式并不支持。&lt;/p&gt;

&lt;p&gt;  通过以上实验，我们可以观察出chrome和safari对于不同格式的时间字符串的支持情况。chrome同时支持&#39;-&#39;和&#39;/&#39;分割日期的时间字符串；safari不支持&#39;-&#39;分割日期的时间字符串。&lt;/p&gt;

&lt;h2&gt;一个简单有效的解决方法&lt;/h2&gt;

&lt;p&gt;  下面是一个比较好的解决方案：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = &quot;2010-03-15 10:30:00&quot;.split(/[- / :]/),
    date = new Date(arr[0], arr[1]-1, arr[2], arr[3], arr[4], arr[5]);

  console.log(date);
  //-&amp;gt; Mon Mar 15 2010 10:30:00 GMT+0000 (GMT Standard Time)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   该方法为先将时间字符串用split方法进行分割拼装为一个数组，再将每个数组的项作为传参传入new Date()方法，从而将不同形式的字符串转换成有效的时间。
   该方法对于所有浏览器生效。&lt;/p&gt;

&lt;h2&gt;参考资料：&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5324178/javascript-date-parsing-on-iphone&quot;&gt;http://stackoverflow.com/questions/5324178/javascript-date-parsing-on-iphone&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>网站分析指标</title>
     <link href="http://korbinzhao.github.io/key-indicator-website-analysis"/>
     <updated>2015-11-01T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/key-indicator-website-analysis</id>
     <content type="html">&lt;h2&gt;1. UV（Unique Vistor）&lt;/h2&gt;

&lt;p&gt;UV是指唯一的访问者。00:00-24:00内相同的UV只被计算一次。&lt;/p&gt;

&lt;h3&gt;网站分析工具如何辨别UV&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;通过服务器
服务器从浏览器接收到的每次请求都会包含IP、请求时间、浏览器版本、操作系统版本等很多信息，服务器可以根据某些共同特征，来判断是否是同一个UV。不过根据IP判断UV并不十分准确，尤其是在公用IP的局域网环境下。&lt;/li&gt;
&lt;li&gt;通过cookie
浏览器第一次访问某个网站服务器时，服务器会给浏览器发送一个cookie，这个cookie会分配给你一个独一无二的编号，并且会记录你访问服务器的信息，例如访问时间、访问的网页、是否登录、登录的账号信息等。当浏览器再一次访问服务器时，服务器获取到cookie，并对里面的信息进行更新，但是给你的编号是不会变的。cookie中拥有相同编号的两个请求会被认定为同一个visitor。这个方法比上一个更精确些，但是在浏览器禁用cookie或者用户经常删除cookie的情况下，这种方式也将失效。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2. PV（Page View）&lt;/h2&gt;

&lt;p&gt;PV（page view），即页面浏览量，或点击量。一个PV指的是一次从网站下载一个页面的请求（A page view or page impression is a request to load a single page of an Internet site.）。&lt;/p&gt;

&lt;h2&gt;3. Bounce Rate&lt;/h2&gt;

&lt;p&gt;Bounce Rate，指的是在对一个页面的所有访问中，只浏览却没有发生任何点击的访问所占的比率。这种跳失一般发生在用户误点跳转链接或是进入网页后发现内容非常不感兴趣时。&lt;/p&gt;

&lt;p&gt;用一个公式来表示Bounce Rate，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Omniture的计算方法：

Bounce Rate = Single Page Visits / Total Visits
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过Bounce Rate存在另一种计算方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Google Analytics等工具的计算方法：

Bounce Rate = Single PV Visits / Total Visits 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Page Visits 和 PV Visits的主要区别在于在用户刷新时，对visits的统计是否会+1. 举例说明，用户进入页面后在没有任何操作情况下，刷新一次页面Page Visits不会+1，而PV就会+1，使得PV变为2.&lt;/p&gt;

&lt;p&gt;这两种计算方法的具体区别详见&lt;a href=&quot;http://www.woshipm.com/operate/83233.html&quot;&gt;网站分析的最基本度量&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;4. 跳失率&lt;/h2&gt;

&lt;p&gt;业界有『exit rate』和『bounce rate』两个概念，其中『exit rate』指该网页是会话中『最后一页』的浏览占此网页总浏览量的百分比，而『bounce rate』是指该网页是会话中“唯一网页”的会话占从此网页开始的所有会话的百分比。&lt;/p&gt;

&lt;h2&gt;PS：&lt;/h2&gt;

&lt;p&gt;当然，以上这些概念只是行业通用的一些行业，有些甚至没有统一的界定和标准。每个公司都有自己的一套界定规范。如果你是身在职场的孩子，不妨详细了解下本公司对各网站分析指标的详细界定。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>原生JS实现页面滚动方向检测</title>
     <link href="http://korbinzhao.github.io/js-scroll-direction"/>
     <updated>2015-10-27T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/js-scroll-direction</id>
     <content type="html">&lt;p&gt;判断页面滚动方向是一个常见的需求，下面展示一个使用原生JS方式判断页面滚动方向的解决方式。&lt;/p&gt;

&lt;h2&gt;html&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://g.tbcdn.cn/tb/kimi/0.0.233/kimi.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;body style=&quot;height: 6000px;&quot;&amp;gt;
    &amp;lt;div class=&quot;nav&quot; style=&quot;position:fixed; top:0;left:0;width: 100%;height: 60px;background-color: pink;&quot;&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;js&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  var $nav = $(&#39;.nav&#39;);
  var $result = $(&#39;.result&#39;);

  //页面滚动监听事件
  window.onscroll = function(e){
    $result.html(&#39;swipeDown&#39;);
    scrollFunc();
    if(scrollDirection == &#39;down&#39;){
      $nav.css({
        position: &#39;absolute&#39;
      });
    }
    else if(scrollDirection == &#39;up&#39;){
      $nav.css({
        position: &#39;fixed&#39;
      });
    }
  }
  var scrollAction = {x: &#39;undefined&#39;, y: &#39;undefined&#39;}, scrollDirection;

  //判断页面滚动方向
  function scrollFunc() {
    if (typeof scrollAction.x == &#39;undefined&#39;) {
      scrollAction.x = window.pageXOffset;
      scrollAction.y = window.pageYOffset;
    }
    var diffX = scrollAction.x - window.pageXOffset;
    var diffY = scrollAction.y - window.pageYOffset;
    if (diffX &amp;lt; 0) {
    // Scroll right
      scrollDirection = &#39;right&#39;;
    } else if (diffX &amp;gt; 0) {
    // Scroll left
      scrollDirection = &#39;left&#39;;
    } else if (diffY &amp;lt; 0) {
    // Scroll down
      scrollDirection = &#39;down&#39;;
    } else if (diffY &amp;gt; 0) {
    // Scroll up
      scrollDirection = &#39;up&#39;;
    } else {
    // First scroll event
    }
    scrollAction.x = window.pageXOffset;
    scrollAction.y = window.pageYOffset;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;github地址&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/korbinzhao/exercise/blob/master/js-scroll-direction.html
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>前端模块化规范 - CommonJS、AMD & CMD</title>
     <link href="http://korbinzhao.github.io/commonjs-amd-cmd"/>
     <updated>2015-10-25T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/commonjs-amd-cmd</id>
     <content type="html">&lt;p&gt;前端为什么会出现模块化这个概念，主要原因是随着前端项目的复杂性和项目团队规模的扩大，命名冲突和文件依赖成为影响前端开发效率的两个重要问题。模块化规范的另一个目的是提高JS程序的可移植性。&lt;/p&gt;

&lt;h2&gt;CommonJS&lt;/h2&gt;

&lt;p&gt;官方JavaScript规范定义的API主要是为了构建基于浏览器端的应用程序。在服务器端，并没有官方的API定义。&lt;/p&gt;

&lt;p&gt;CommonJS定义了许多普通应用程序（主要指非浏览器应用）使用的API，它的终极目标是提供一个类似Python、Ruby和Java的标准库，从而开发者可以使用CommonJS API编写可以运行在不同JS解释器和不同主机环境的应用程序。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NodeJS和CommonJS之间的关系&lt;/p&gt;

&lt;p&gt;  CommonJS是一种规范，NodeJS是这种规范的实现。JavaScript作为本地变成语言这种特殊应用程序，也是随着NodeJS的火热而进入大众的视野。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;浏览器加载 CommonJS 模块的原理与实现&lt;/p&gt;

&lt;p&gt;  npm的模块都是JS语言写的，但是浏览器用不了，因为浏览器不支持CommonJS格式。要想让浏览器用上这些模块，必须转换格式。&lt;/p&gt;

&lt;p&gt;  浏览器不兼容CommonJS的根本原因，在于缺少四个Node.js环境的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  module
  exports
  require
  global
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  只要能够提供这四个变量，浏览器就能加载CommonJS模块。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Browserify的实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;知道了原理，就能做出工具了。Browserify（require(&#39;modules&#39;) in the browser）是目前最常用的CommonJS格式转换的工具。&lt;/p&gt;

&lt;p&gt;举例：
main.js模块加载foo.js模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// foo.js
module.exports = function(x) {
  console.log(x);
};

// main.js
var foo = require(&quot;./foo&quot;);
foo(&quot;Hi&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面的命令，就能将main.js转为浏览器可用的格式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ browserify main.js &amp;gt; compiled.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Browserify到底做了什么？安装一下browser-unpack，就能看清楚了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install browser-unpack -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，将前面生成的compile.js解包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ browser-unpack &amp;lt; compiled.js

[
  {
    &quot;id&quot;:1,
    &quot;source&quot;:&quot;module.exports = function(x) {\n  console.log(x);\n};&quot;,
    &quot;deps&quot;:{}
  },
  {
    &quot;id&quot;:2,
    &quot;source&quot;:&quot;var foo = require(\&quot;./foo\&quot;);\nfoo(\&quot;Hi\&quot;);&quot;,
    &quot;deps&quot;:{&quot;./foo&quot;:1},
    &quot;entry&quot;:true
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，browerify将所有模块放入一个数组，id属性是模块的编号，source属性是模块的源码，deps属性是模块的依赖。&lt;/p&gt;

&lt;p&gt;因为main.js里面加载了foo.js，所以deps属性就制定./foo对应的1号模块。执行的时候，浏览器遇到require(&#39;./foo&#39;)语句，就自动执行1号模块的source属性，并就爱那个执行后的module.exports属性值输出。&lt;/p&gt;

&lt;h2&gt;AMD&lt;/h2&gt;

&lt;p&gt;AMD（异步模块定，Asynchronous Module Definition）格式总体的目标是为现在的开发者提供一个可用的模块化JS解决方案。&lt;/p&gt;

&lt;p&gt;CommonJS通过引入模块化使得在服务器端编写JS应用成为可能，但是由于一个重大的局限，使得CommonJS规范不适用与浏览器环境。举例如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var math = require(&#39;math&#39;);
　　math.add(2, 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二行math.add(2, 3)，在第一行require(&#39;math&#39;)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。&lt;/p&gt;

&lt;p&gt;这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这确实一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于“假死”状态。&lt;/p&gt;

&lt;p&gt;因此，浏览器端的模块，不能采用“同步加载”（synchronous），只能采用“异步加载”（asynchronous）。这就是AMD规范诞生的背景。&lt;/p&gt;

&lt;p&gt;AMD是“Asynchronous Module Definition”的缩写，意思就是“异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。&lt;/p&gt;

&lt;p&gt;AMD也采用require()语句加载模块，但是不同于CommonJS，他要求两个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require([module], callback);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。&lt;/p&gt;

&lt;h2&gt;CMD&lt;/h2&gt;

&lt;p&gt;CMD（Common Module Definition）模块定义规范，是@玉伯提出的一个类似于AMD的规范，该规范明确了模块的基本书写格式和基本交互规则。&lt;/p&gt;

&lt;h3&gt;AMD和CMD的区别&lt;/h3&gt;

&lt;p&gt;下面来看下@玉伯给出的官方解释。&lt;/p&gt;

&lt;p&gt;AMD和CMD等规范的目的都是为了JS的模块化开发，特别是在浏览器端的。目前这些规范的实现都能达成浏览器端模块化开发的目的。&lt;/p&gt;

&lt;p&gt;区别在于：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于依赖的模块，AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD推崇as lazy as possible。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CMD推崇依赖就近，AMD推崇依赖前置。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; // CMD
 define(function(require, exports, module) {   
     var a = require(&#39;./a&#39;)   
     a.doSomething()   
     // 此处略去 100 行   
     var b = require(&#39;./b&#39;) // 依赖可以就近书写   
     b.doSomething()   
     // ... 
 })

 // AMD 默认推荐的是
 define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) {  
     // 依赖必须一开始就写好    
     a.doSomething()    
     // 此处略去 100 行    
     b.doSomething()    
     ...
 })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 虽然AMD也支持CMD的写法，同时还支持require作为依赖项传递，但RequireJS官方文档里默认上面的模块定义写法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AMD的API默认是一个当多个用，CMD的API严格区分，推崇职责单一。比如AMD里，require分全局require和局部require，都叫require。CMD里，没有全局require，而是根据模块系统的完备性，提供seajs.use来实现模块系统的加载启动。CMD里，每个API都简单纯粹。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/fullhouse/archive/2011/07/15/2107416.html&quot;&gt;什么是CommonJS？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.feeldesignstudio.com/2013/09/javascript-module-pattern-commonjs/&quot;&gt;JavaScript模块化开发（二）——CommonJS规范&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html&quot;&gt;浏览器加载 CommonJS 模块的原理与实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html&quot;&gt;Javascript模块化编程（二）：AMD规范&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/20351507&quot;&gt;AMD 和 CMD 的区别有哪些？- 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>JS跨域问题解决方式</title>
     <link href="http://korbinzhao.github.io/cross-origin-js"/>
     <updated>2015-10-23T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/cross-origin-js</id>
     <content type="html">&lt;p&gt;所谓跨域，或者异源，是指主机名（域名）、协议、端口号只要有其一不同，就为不同的域（或源）。浏览器中有一个基本的策略，叫同源策略，即限制“源”自A的脚本只能操作“同源”页面的DOM。以下列举几种跨域方式。&lt;/p&gt;

&lt;h2&gt;1.CORS&lt;/h2&gt;

&lt;p&gt;Cross-Origin Resource Sharing，跨域资源共享，简称 CORS。CORS系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。跨域资源共享是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。&lt;/p&gt;

&lt;p&gt;CORS(Cross-Origin Resource Sharing,􏰛源􏰉源共􏰠)是 W3C 的一个工作􏰡案,定义了在必须访问跨源资源时,浏览器与服􏰁务器应该如何􏰢沟通。CORS背􏰣后的基本思想,就是使用自定义的HTTP头部让浏览器与服􏰁务器进行沟􏰢通,从而决定请求或响应是应该成功,还是应该失败。&lt;/p&gt;

&lt;p&gt;具体如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个简单的使用GET或POST发􏰀的请求,它没有自定义的头部,而主体内容是text/plain。在发送􏰀该请求时,需要给它􏰤加一个􏰥额外的Origin头部,其中包含请求􏰝面的源信息(协􏰦议、域名和􏰧端口),以便服􏰁务器根据这个头部信息来决定是否给予响应。下面是 Origin 头部的一个示例:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 消费者发送一个Origin报头到提供者端：Origin: http://www.a.com；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;提供者发送一个Access-Control-Allow-Origin响应报头给消费者，如果值为“*”或Origin对应的站点，则表示同意共享资源给消费者，如果值为null或者不存在Access-Control-Allow-Origin报头，则表示不同意共享资源给消费者；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果没有这个头部,或者有这个头部但源信息不匹配,浏览器就会驳􏰩回请求。正常情况下,浏览器会处理请求&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;注：CORS支持GET/POST请求方式&lt;/p&gt;

&lt;h2&gt;2.JSONP&lt;/h2&gt;

&lt;p&gt;JSONP 是 JSON with padding(填充式 JSON 或参数式 JSON)的简写。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;callback({ &quot;name&quot;: &quot;Nicholas&quot; });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于一段JavaScript脚本来说，其“源”与它存储的地址无关，而取决于脚本被加载的页面，例如我们在页面中使用script引入存储在其他域的脚本文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://www.a.com/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里脚本与当前页面是同源的。除了script，还有img、iframe、link等都具有跨域加载资源的能力。&lt;/p&gt;

&lt;p&gt;Jsonp正是利用这种特性来实现跨域的：在页面中引入要跨域访问的来源，并定义回调函数处理跨域访问得到的json数据。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var script = document.createElement(&quot;script&quot;);
  script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;
  document.body.insertBefore(script, document.body.firstChild);

  function handleResponse(response){
    console.log(&quot;You are at IP address &quot; + response.ip + &quot;, which is in &quot; +
        response.city + &quot;, &quot; + response.region_name);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：JSONP只支持GET请求方式&lt;/p&gt;

&lt;h2&gt;3.修改document.domain来跨子域&lt;/h2&gt;

&lt;p&gt;www.a.com/1.html和a.com/2.html是不同域的，要使他们可以跨域访问，可通过修改document.domain来实现，即在两个页面中都设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.domain=&quot;a.com&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是document.domain只能往父级修改，如a.com改为www.a.com是不被允许的，这也是此方法的局限性，只使用于跨子域访问。&lt;/p&gt;

&lt;h2&gt;4.使用window.name来跨域访问&lt;/h2&gt;

&lt;p&gt;window.name是同一浏览器窗口下载入的所有页面共享的数据字段，所有窗口都可以读写此字段的内容。&lt;/p&gt;

&lt;p&gt;所以假设a.com要访问b.com的数据，只需要在b.com中将数据放在window.name中，然后a.com从中取出即可。此方法适用于像iframe这样的嵌套页面架构。&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000003784372&quot;&gt;浅谈js跨域问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;JavaScript高级程序设计&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>入职了，转正了</title>
     <link href="http://korbinzhao.github.io/become-a-regular-worker"/>
     <updated>2015-10-23T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/become-a-regular-worker</id>
     <content type="html">&lt;p&gt;正式入职3个月，经过了转正面试，接连有了两次转正后的交流会。今晚这次交流比较有感触，所以特别记一下。&lt;/p&gt;

&lt;p&gt;前两天，团队新近的6个新人全部转正面试结束。老板ZY把我们同组的6个人叫到一起，开了个简单的交流会。此前的转正面试加上最近2次交流会，有一些收获，记录一下，给以后工作中的自己提个醒。&lt;/p&gt;

&lt;h2&gt;从业务中抽离出来做些自己的事情&lt;/h2&gt;

&lt;p&gt;我们的日常业务是很忙的。要学会从繁重的业务中抽身出来，去做些个人成长、技术成长的事情。说白了，只做业务的话说实话，最后只是简单一些重复劳动，如果不能自己抽出时间进行学习、积累的话，自己很难会有成长，对于之后的KPI考核、薪酬、晋升其实是没有什么好处的。&lt;/p&gt;

&lt;p&gt;这一点是自从入职后，每次开交流会团队老大YX和HR都会返回强调的。只做业务，没有自己的核心竞争力的话，个人的不可替代性就太强了，对于团队的价值就非常小。&lt;/p&gt;

&lt;h2&gt;工作中思考&lt;/h2&gt;

&lt;p&gt;思考是工作中非常重要的一个能力，不能在工作中有自己的思考，那么你就只能是别人眼中的一个工具。这里的思考既有对前端团队内部效率、工具的思考，也有对自己所负责业务的思考。&lt;/p&gt;

&lt;h2&gt;将自己的思考写出来&lt;/h2&gt;

&lt;p&gt;一些事情自己能想到以及想清楚和真正把想法写出来是完全两种不同的概念。很多时候，我们只是自我感觉把有些东西想清楚了，但是真的当我们需要临场表达的时候常常是毫无逻辑、丢三落四或者混乱不堪的。这说明我们还没有把自己的思路真正的理清楚。那么，平时自己有所思考的时候，把自己的想法写出来吧！&lt;/p&gt;

&lt;p&gt;写作可以让你对自己的过往的思考有一个清晰的回顾和整理，并且当我们回过头来看自己的过往的想法时也是一种意义非法的事情。&lt;/p&gt;

&lt;h2&gt;拓展自己的舒服边界-团队中的充分交流&lt;/h2&gt;

&lt;p&gt;作为一个资深的、被很多人认为很内向的人，在面对长辈和领导时总是会有一种莫名的紧张，会表现的很内向，这个毛病伴随了我20+年。&lt;/p&gt;

&lt;p&gt;要解决这个问题，用今天ZY的一句话来说，就是要拓展自己的舒服边界。每个人都有自己的舒服边界，有的人舒服边界大一些，则表现出来就外向一点，有的人舒服边界小一些，则表现出来就内向一点。&lt;/p&gt;

&lt;p&gt;没办法，平时不能太懒，要多花点时间和团队其他成员交流。&lt;/p&gt;

&lt;p&gt;能想到的一个比较好的方式，&lt;strong&gt;就是在自己迟疑要不要说某句话或者和某人交流的时候，放弃迟疑，果断迈出第一步吧。&lt;/strong&gt;改变是一点点发生的。&lt;/p&gt;

&lt;h2&gt;将自己的实力充分表现出来&lt;/h2&gt;

&lt;p&gt;最后一点感触很深的是，无论你多牛掰，不表现出来，不让你身边的人、老版、HR看到，一切都是白搭的。所以工作中很苦逼的一种状态会是，你每天累得像孙子一样，老板却看不到你的实力、成果。&lt;/p&gt;

&lt;p&gt;所以，适时的把自己的实力、观点表达出来吧~&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Mac OS X 快捷键</title>
     <link href="http://korbinzhao.github.io/mac-os-x-shortcut"/>
     <updated>2015-08-23T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/mac-os-x-shortcut</id>
     <content type="html">&lt;p&gt;Mac OS X 的快捷键会有效提升我们的办公效率，下面是常用的部分快捷键的汇总，并在文章的最后附有详细的系列学习视频&lt;/p&gt;

&lt;p&gt;command+H : 隐藏该程序&lt;/p&gt;

&lt;p&gt;command＋option＋H: 隐藏当前应用外的其它所有应用&lt;/p&gt;

&lt;p&gt;command+, : 呼出应用程序设置&lt;/p&gt;

&lt;p&gt;command+option+v : 剪切&lt;/p&gt;

&lt;p&gt;command+delete: 移到废纸篓&lt;/p&gt;

&lt;p&gt;command+i : 显示简介&lt;/p&gt;

&lt;p&gt;command＋option＋i：查看选中的多个文件的简介&lt;/p&gt;

&lt;p&gt;command+上/下 : 跳到顶部底部&lt;/p&gt;

&lt;p&gt;command＋前／后： 跳到行首行尾&lt;/p&gt;

&lt;p&gt;command＋option＋shift＋v：只粘贴文本，不粘贴样式&lt;/p&gt;

&lt;p&gt;fn+delete: 向后删除&lt;/p&gt;

&lt;p&gt;拖动文件：剪切&lt;/p&gt;

&lt;p&gt;option＋拖动文件：复制&lt;/p&gt;

&lt;p&gt;选中+space（或三指点击触控板） ： 预览&lt;/p&gt;

&lt;p&gt;选中多个文件＋右键 ： 新建文件夹并将选中文件放进去&lt;/p&gt;

&lt;p&gt;在显示简介中修改默认文件打开方式&lt;/p&gt;

&lt;p&gt;四指向上推，呼出MissionControl，按住option添加桌面，四指左右滑动（或command+左/右），切换
桌面&lt;/p&gt;

&lt;p&gt;四指下滑，展示当前应用的所有打开窗口&lt;/p&gt;

&lt;p&gt;在英文输入法状态下长按韵母字母，就可以呼出带有声调的字母符号&lt;/p&gt;

&lt;p&gt;－－－－－－－－－－－－－－－－－－－－－－&lt;/p&gt;

&lt;p&gt;推荐的学习视频：&lt;a href=&quot;http://www.youku.com/playlist_show/id_18654878.html&quot;&gt;深入浅出 Mac OSX 中文教程&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>nodejs+mongdb+express建站学习中所踩得坑</title>
     <link href="http://korbinzhao.github.io/nodejs-express-mongodb-website"/>
     <updated>2015-06-02T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/nodejs-express-mongodb-website</id>
     <content type="html">&lt;h2&gt;网站开发框架&lt;/h2&gt;

&lt;p&gt;在网站开发之前，我们首先对网站开发框架进行设计。主要分为后端、前端、本地开发环境三部分。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;网站后端由nodejs支撑，同时安装nodejs框架express，数据库选择mongodb，同时选择对mongodb进行快速建模的工具mongoose，后端模板引擎选择jade，日期和时间的格式化选择moment.js，express、mongoose、jade、moment.js都通过npm模块安装包来安装。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端选择jQuery类库、Bootstrap样式框架，jQuery和Bootstrap都属于前端静态资源，使用Bower来安装它们，Bower也是一个npm安装模块，因此也需要使用npm安装。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;本地开发环境用到less的编译、cssmin样式合并、JSHint前后端单元测试的实现等。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;img src=&quot;/images/nodejs-express-mongondb-website/website-framework.png&quot; title=&quot;website framework&quot; alt=&quot;website framework&quot; /&gt;&lt;/p&gt;

&lt;p&gt;视频教程详见&lt;a href=&quot;http://www.imooc.com/learn/75&quot; title=&quot;imooc.com&quot;&gt;imooc.com&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;nodejs的安装&lt;/h2&gt;

&lt;p&gt;开发前需要先安装[nodejs]，通过nodejs官网即可完成nodejs的安装。&lt;/p&gt;

&lt;h2&gt;mongodb的安装&lt;/h2&gt;

&lt;p&gt;mongodb是一个高性能、开源、无模式的文档型数据库（非关系型数据库），是当前NoSql数据库中比较热门的一种。mongodb中的一条记录就是一个文档（document），它的数据结构由键值对组成。mongodb文档和JSON对象很相似。&lt;/p&gt;

&lt;p&gt;拓展：NoSql，全称是Not Only Sql，指的是非关系型数据库。下一代数据库主要解决几个要点：非关系型、分布式、开源、水平可拓展。&lt;/p&gt;

&lt;p&gt;开发前mongodb需要单独安装。这也是我在不了解情况下踩过的一个坑，mongoose是mongodb的快速建模工具，通过npm安装mongoose并不会同时安装mongodb，且在安装完成mongobd后，在运行node app.&lt;/p&gt;

&lt;p&gt;首先安装&lt;a href=&quot;https://www.mongodb.org/&quot; title=&quot;mongodb&quot;&gt;mongodb&lt;/a&gt;,js本地查看网站效果前，必须前行启动mongodb，并与node连接起来。在项目文件夹imooc下新建data文件夹用于存放mongdb数据。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd d:/fe_exercise/imooc
mkdir data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入mongodb的安装目录 D:\Program Files\MongoDB 2.6 Standard下的bin文件夹中执行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd d:/Program Files/MongoDB 2.6 Standard/bin
mongod --dbpath &quot;d:/fe_exercise/imooc/data&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现以下结果则证明连接成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/nodejs-express-mongondb-website/mongodb-node-link.png&quot; title=&quot;mongodb-node-link&quot; alt=&quot;mongodb-node-link&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每次本地查看网站前，用命令行启动mongodb，并将mongodb和node连接是一件很麻烦的事情。可以通过一种相对简单方法可以简化这个过程。具体方法如下：&lt;/p&gt;

&lt;p&gt;新建一个名为mongodb.cmd的文件，文件内容如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:: 定位到D盘
d:
:: 切换到mongodb的数据库目录
cd Program files\MongoDB 2.6 Standard\data
:: 删除数据库锁定记录文件
if exist mongod.lock del mongod.lock missing
:: 切换到mongodb的bin目录
cd ..\bin
:: 配置mongodb的文档存储目录
mongod --dbpath &quot;D:\fe_exercise\imooc\data&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;双击运行，即可完成启动mongodb，连接mongodb和node的过程。&lt;/p&gt;

&lt;h2&gt;mongodb可视化管理工具：rockmongo的安装与配置&lt;/h2&gt;

&lt;p&gt;rockmongo是一个用PHP5写的mongodb可视化管理工具。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下载rockmongo&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://rockmongo.com/downloads&quot; title=&quot;rockmongo&quot;&gt;rockmongo官网&lt;/a&gt;目前无法访问，可选择另一种替代方式：直接访问&lt;a href=&quot;https://github.com/iwind/rockmongo&quot; title=&quot;rockmongo&quot;&gt;rockmongo github地址&lt;/a&gt;，选择一个版本进行下载，本文选用1.1.7版本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;安装PHP环境&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;rockmongo的运行需要PHP环境，本文选用&lt;a href=&quot;http://pan.baidu.com/s/1c0dInYg&quot; title=&quot;appserv&quot;&gt;AppServ 2.5.1&lt;/a&gt;进行PHP、Apache等环境的打包安装，AppServ是PHP网页架站工具组合包，所包含的软件有：Apache、Apache Monitor、MySQL、PHPMyAdmin等。AppServ 2.5.1中PHP版本为PHP 5.2。下载AppServ点击安装，本文选用安装目录为C:/AppServ。&lt;/p&gt;

&lt;p&gt;将上文中从github上下载的rockmongo 1.1.7文件夹重命名为rockmongo，放到AppServ安装目录下的www文件夹中：C:/AppServ/www。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下载mongodb-php拓展&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据所安装的PHP版本选择相应的mongo-php驱动拓展，本文PHP版本为5.2，因此选择PHP 5.2 VC6 Thread-Safe Mongo extension：&lt;a href=&quot;http://pan.baidu.com/s/1eQo33kI&quot; title=&quot;mongo-php-driver&quot;&gt;mongo-php-driver&lt;/a&gt;，将下载目录中的php_mongo.dll文件copy到C:/AppServ/php5/ext中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;修改php.ini文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在php.ini文件中添加extension=php_mongo.dll&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;重启Apache服务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;重启Apache服务&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;修改rockmongo中的文件config..php&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置以下内容的USERNAME和PASSWORD，将两者均设为root&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$MONGO[&quot;servers&quot;][$i][&quot;control_users&quot;][&quot;root&quot;] = &quot;root&quot;;//one of control users [&quot;USERNAME&quot;]=PASSWORD, works only if mongo_auth=false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;使用rockmongo登录mongodb&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;访问http://localhost/rockmongo,界面如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/nodejs-express-mongondb-website/login.png&quot; title=&quot;login&quot; alt=&quot;login&quot; /&gt;&lt;/p&gt;

&lt;p&gt;登录后界面如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/nodejs-express-mongondb-website/dbview.png&quot; title=&quot;dbview&quot; alt=&quot;dbview&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;项目结构的初始化&lt;/h2&gt;

&lt;p&gt;进入项目目录，运行Node.js command prompt,运行以下代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- imooc/
 &amp;gt; npm install express
 &amp;gt; npm install jade
 &amp;gt; npm install mongoose
 &amp;gt; npm install bower -g
 &amp;gt; npm install bootstrap
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过npm对项目中使用的框架和模块进行安装之后就可以正式开始项目开发了。具体项目源码见&lt;a href=&quot;https://github.com/korbinzhao/exercise/tree/master/imooc&quot; title=&quot;imooc github&quot;&gt;github仓库&lt;/a&gt;。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>SVG入门</title>
     <link href="http://korbinzhao.github.io/introduction-to-svg"/>
     <updated>2015-06-02T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/introduction-to-svg</id>
     <content type="html">&lt;h2&gt;SVG&lt;/h2&gt;

&lt;p&gt;SVG是使用XML描述的矢量文件，全称可缩放矢量图形，用于描述二维矢量图形的一种图形格式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;位图&amp;amp;矢量图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;位图（BMP、PNG、JPG等）是基于颜色的描述，由一个个像素点组成；矢量图（SVG、AI等）是基于数学的描述，根据几何特征来绘制图形，矢量可以是一个点或一条线，矢量图只能靠软件生成，特点是放大后图像不会失真，和分辨率无关。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/introduction-to-svg/svg.png&quot; title=&quot;svg&quot; alt=&quot;svg&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;SVG示例&lt;/h2&gt;

&lt;p&gt;simple.svg&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;200&quot; height=&quot;200&quot;&amp;gt;
&amp;lt;!--face--&amp;gt;
&amp;lt;circle cx=&quot;100&quot; cy=&quot;100&quot; r=&quot;90&quot; fill=&quot;#39F&quot;/&amp;gt;
&amp;lt;!--eyes--&amp;gt;
&amp;lt;circle cx=&quot;70&quot; cy=&quot;80&quot; r=&quot;20&quot; fill=&quot;white&quot;/&amp;gt;
&amp;lt;circle cx=&quot;130&quot; cy=&quot;80&quot; r=&quot;20&quot; fill=&quot;white&quot;/&amp;gt;
&amp;lt;circle cx=&quot;65&quot; cy=&quot;75&quot; r=&quot;10&quot; fill=&quot;black&quot;/&amp;gt;
&amp;lt;circle cx=&quot;125&quot; cy=&quot;75&quot; r=&quot;10&quot; fill=&quot;black&quot;/&amp;gt;
&amp;lt;!--smile--&amp;gt;
&amp;lt;path d=&quot;M 50 140 A 60 60 0 0 0 150 140&quot; stroke=&quot;white&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&amp;gt;
&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;SVG的使用方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;浏览器直接打开&lt;/li&gt;
&lt;li&gt;在HTML中使用img标签引用&lt;/li&gt;
&lt;li&gt;直接在HTML中使用SVG&lt;/li&gt;
&lt;li&gt;作为CSS背景&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;基本操作API&lt;/h2&gt;

&lt;p&gt;创建图形，需要使用document.createElementNS()方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.createElementNS(ns, tagName)
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
 
</feed>
