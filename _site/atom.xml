<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>Joebon's world</title>
   <link href="http://joebon.cc/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://joebon.cc" rel="alternate" type="text/html" />
   <updated>2016-01-17T22:17:19+08:00</updated>
   <id>http://joebon.cc</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>模拟form表单上传图片</title>
     <link href="http://korbinzhao.github.io/upload-image-simulate-post-form"/>
     <updated>2016-01-17T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/upload-image-simulate-post-form</id>
     <content type="html">&lt;p&gt;浏览器端：
html：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;form id=&quot;fileupload&quot; class=&quot;fileupload form-upload&quot; style=&quot;display:none;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;javascript:;&quot; role = &quot;form&quot;&amp;gt;\
    &amp;lt;input type = &quot;file&quot; name = &quot;files&quot; class=&quot;file-input&quot; /&amp;gt; \
    &amp;lt;input type=&quot;hidden&quot; name=&quot;modulename&quot; value=&quot;&quot;/&amp;gt;\
    &amp;lt;input type=&quot;button&quot; class=&quot;upload-btn J_Uploadimg&quot;  value=&quot;上传截图&quot;/&amp;gt;\
&amp;lt;/form&amp;gt;\
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $fileUpload = $(&quot;.fileupload&quot;);

var formData = new FormData($fileUpload[0]);

    $.ajax({
        url: &#39;/api/upload_img&#39;,
        type: &#39;POST&#39;,   
        data: formData,
        async: false,
        cache: false,
        contentType: false,
        processData: false,
        success: function(data){
            nanobar.go(100);
            //异步化
            if(data.success){
                $(&#39;#J_MsgCenter&#39;).html($.substitute(&#39;&amp;lt;span class=&quot;label label-success&quot;&amp;gt;{message}&amp;lt;/span&amp;gt;&#39;,{message:data.message}));
            }
            else{
                $(&#39;#J_MsgCenter&#39;).html($.substitute(&#39;&amp;lt;span class=&quot;label label-danger&quot;&amp;gt;{message}&amp;lt;/span&amp;gt;&#39;,{message:data.message}));
            }   
            node.removeClass(&#39;disabled&#39;);
            if(node.attr(&#39;data-reload&#39;)){
                window.location.reload();
            }
            console.log(&#39;imgUploader upload success, data:&#39;, data);
        },
        error: function(){
            $(&quot;#spanMessage&quot;).html(&quot;与服务器通信发生错误&quot;);
        }
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器端：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function (req, res, next) {

new Promise(function(resolve, reject){

res.append(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);

var form = new multiparty.Form();

form.parse(req, function(err, fields, files) {

  console.log(&#39;fields:&#39;);
  console.log(fields);

  console.log(&#39;files:&#39;);
  console.log(files);

  var modulename = fields.modulename[0];

  var modulePath = path.join(work_path, &#39;module&#39;, modulename);
  var imgPath = files.files[0].path;

  uploadImg(imgPath, modulePath, resolve, reject);

});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  })&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>剪切板粘贴上传图片功能的实现</title>
     <link href="http://korbinzhao.github.io/clipboard-image-upload"/>
     <updated>2016-01-17T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/clipboard-image-upload</id>
     <content type="html">&lt;p&gt;平时的开发中我们难免要上传一些网页截图，传统的选择文件上传使用起来不方便，这里介绍一种使用js和node实现的剪切板黏贴上传图片功能。当我们需要上传截图时，只需手动截图后commond/ctrl+v即可完成图片上传。这种方式将大大减少我们在上传图片过程中花费的时间。&lt;/p&gt;

&lt;p&gt;要实现剪切板黏贴上传功能，首先我们要先能获取到在剪切板中的图片，这里给大家介绍一个很好用的js插件：&lt;a href=&quot;https://github.com/jorgenbs/ImageClipboard&quot;&gt;ImageClipboard&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;ImageClipboard&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jorgenbs/ImageClipboard&quot;&gt;ImageClipboard&lt;/a&gt;是一款在chrome、firefox和opera上有效的可以将剪切板中的图片黏贴到网页上的工具。&lt;/p&gt;

&lt;h3&gt;安装&lt;/h3&gt;

&lt;p&gt;可以使用bower很简单的安装，如果没有安装bower，请先安装bower,安装使用说明见：&lt;a href=&quot;http://javascript.ruanyifeng.com/tool/bower.html&quot;&gt;bower：客户端库管理工具&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bower install image-clipboard
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;使用：将剪切板中的图片黏贴到网页中去&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;ImageClipBoard.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;

 var clipboard = new ImageClipboard(&#39;#box&#39;, function (base64) {
    //do stuff with pasted image
 });

  //onpaste-callback can also be passed as second argument
  //in the constructor above.
 clipboard.onpaste = function (base64) {
    //do stuff with the pasted image
  });

  //you can also pass in single DOM-element instead of 
  //query as the first parameter.

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  运行以上代码后，div#box中会插入一个img标签，src即为当前剪切板中图片。&lt;/p&gt;

&lt;h2&gt;剪切板中图片的获取与上传&lt;/h2&gt;

&lt;p&gt;通过ImageClipboard，我们可以以base64的形式获取到剪切板中的图片，然后将base64数据作为参数通过POST的方式传输到服务器端。&lt;/p&gt;

&lt;h3&gt;浏览器端代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;this.props.clipboard.onpaste = function (base64) {
  //do stuff with the pasted image
  //console.log(base64)

  $.ajax({
    url: &#39;http://localhost:2929/api/upload-img&#39;,
    dataType: &#39;JSON&#39;,
    data: {
      imgData: base64},
    type: &#39;POST&#39;,
    success: function(data) {
      console.log(data);
    }
  });

};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;服务器端代码&lt;/h3&gt;

&lt;p&gt;服务器端获取到base64数据，即可将base64数据转为图片存储或者传送到其他服务器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export default function uploadImg(req, res) {

  new Promise((resolve, reject) =&amp;gt; {

    var fs = require(&#39;fs&#39;);
    var base64Data = req.body.imgData.replace(/^data:image\/png;base64,/, &quot;&quot;);

    fs.writeFile(&quot;out.png&quot;, base64Data, &#39;base64&#39;, function(err) {
      console.log(err);
    });  

  });

}
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>关于生活方式</title>
     <link href="http://korbinzhao.github.io/about-life-style"/>
     <updated>2015-11-23T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/about-life-style</id>
     <content type="html">&lt;p&gt;最近对生活方式有点感悟，正式因为意识到自己正拥有着一种槽糕的生活方式，并萌生了要改变的想法。&lt;/p&gt;

&lt;h2&gt;关于过去&lt;/h2&gt;

&lt;p&gt;平时工作累了，回到家往床上一躺，打开电脑这里点点那里点点，也不知道自己到底在干什么，时间飞快的过去。美其名曰是放空自己，实际上是一种彻头彻尾的逃避和浪费时间，想想这种方式只会让自己很消沉、沉浸在自己的情绪里难以自拔。浪费完时间，发现本来可以做的事情一件都没做，于是自己又陷入一种紧张感，让自己永远生活在一种紧迫之中。&lt;/p&gt;

&lt;p&gt;这种状态从研三到现在已经持续了相当长一段时间了。或许是自己的内心太不强大，或许是太不会一个人生活。无论是什么原因，其实都迫切需要解决，不能期待他人拯救，只能自我救赎。&lt;/p&gt;

&lt;p&gt;我习惯的状态是怎样的呢？彻彻底底的放空自己，什么都不想，什么都不面对。如果可以一直这样倒还挺好。但是现实是我们都不得不回到现实，照照镜子要面对自己，在公司要面对工作中的琐事。。一颗懒散疲惫的心得不到正确的放松和休息，只会让自己陷入恶性循环。&lt;/p&gt;

&lt;p&gt;这就是我经历着的过去。&lt;/p&gt;

&lt;h2&gt;关于快乐&lt;/h2&gt;

&lt;p&gt;其实大多数人都知道生活的本质就是快乐。但是正如《后会无期》里的一句台词：“听过很多道理，依然过不好这一生。” 我很想时时刻刻快乐，但是事实好像并不如人意。&lt;/p&gt;

&lt;p&gt;回想过去快乐的时光，全部都是和朋友们一起的时光。我怀念2011年的夏天，在中山实习的短短1个月，让我彻底忘却所有烦恼，心中没有一丁点的负担，不会为过去做的窘事懊恼，不会对未来担忧。每一分每一秒都是纯粹的开心。快乐到已经忘却整个世界，或者是觉得当时的生活就是整个世界。这或许就是朋友和陪伴的力量，那种轻松和自在是我自从初中开始就从未拥有过的。十年寒窗的坚持让我习惯了用一种苦涩去面对现实和未来，我仿佛失去了快乐的能力。感谢那个夏天让我重拾了快乐的能力，感谢那时陪在我身边的人。我怀念工作后浙西大峡谷的自驾行，虽然只发生在不久前，虽然作为一个闪亮的灯泡照耀在两对情侣身边，但是很感谢有两位即使有女朋友依旧没有忘记我的朋友，我感受到被朋友重视的感觉，我很珍惜和你们在一起的每分每秒。我怀念PD邀请一群工作伙伴一起吃的一顿饭，让我感受到你们生活的精致和追求，让我感受到和不同岗位一伙伴一起交流的乐趣。。这个世界很大，有趣的人太多，不落单的时光才是快乐的时光。&lt;/p&gt;

&lt;p&gt;当我独立面对自己，总会陷入一种难以自拔的窘境。所以我说，我太不会一个人生活。我只会用懒散的状态去放空自己，计划中的事情总是拖到不能再拖的时候才会去做，最后白白浪费大量空闲时间。等到突然意识到一大堆事情没做的时候，又会更加加剧自己的焦躁心理，从而陷入一种恶性循环。这是一个可怕的循环，我现在正在反复经历着。每当独处的时候都会很不快乐，以上分析就是现在这种糟糕状态的根本原因。&lt;/p&gt;

&lt;p&gt;只有跳出这个循环，只有充分利用这些空闲时间，你才能活出自己的生活，积累出超出别人的工作成绩。如果这种状态不改变，只能一直平凡、平庸下去。&lt;/p&gt;

&lt;h2&gt;关于生活方式&lt;/h2&gt;

&lt;p&gt;上一节里分析了我为什么独处的时候那么不快乐。那么到底要怎样摆脱这种恶性循环呢。我能想到的答案就是生活方式的一种改变，或者说是一种习惯的养成。&lt;/p&gt;

&lt;h3&gt;晚上回家后，不管多累先洗澡&lt;/h3&gt;

&lt;p&gt;现在的现状是每天一回家，累得浑身好像一点力气都没有，浑身的疲累和一脸的油全然不顾，就往床上一躺，打开电脑开始漫无目的的上网、看视频，最后时间飞快的到了12点多，然后洗个澡，然后又变精神了，最后折腾折腾，不到1点半肯定是没法安心入睡的，第二天一觉睡到九点多挣扎着起来，上班的时候也没啥精神。这是一个很坏的习惯，浪费了时间，养成了坏的作息习惯，也不利于身体健康。&lt;/p&gt;

&lt;p&gt;所以回到家后，先洗澡，让自己从疲劳的状态中暂时精神起来，然后就可以把今天的工作整理整理，文章写一写，运动做一下。最后累了，躺在床上安然入睡。&lt;/p&gt;

&lt;h3&gt;床只能是睡觉的地方。躺在床上玩电脑，玩手机，赖床这种行为绝对禁止。&lt;/h3&gt;

&lt;p&gt;为什么每天很晚才能睡着，很重要的一个原因是回到家后，基本大部分行为都是在床上完成的，比如看视频，玩手机游戏。玩手机、看视频本身就是让人精神亢奋的事情，当然很难入睡，长期养成条件反射行为，人一到床上就兴奋的没有睡意，而不是一沾枕头就着。&lt;/p&gt;

&lt;h3&gt;椅子靠背不许用。&lt;/h3&gt;

&lt;p&gt;之前的一个很大的坏习惯是每次坐在椅子上其实都只能用“瘫坐”这个词来形容。仿佛没有脊椎一样，一定要靠在椅背上才算舒服。但是长时间靠椅背会让人很快进入疲劳状态还不自觉，瘫坐在椅子上很长时间，虽然很累，却也懒得起来活动一下。长时间的瘫坐在椅子上，还会形成弯腰驼背，容易得脊椎病。直挺挺的坐在椅子上恰恰相反，脊椎会利用自身的自然弯曲分散上身重量，久坐也不易感觉疲累，更不会弯腰驼背，累了也会很自然的站起来活动，不会有倦怠心理，连站起来活动都懒得做（这种行为和赖床也有点像，躺在床上越累越不愿起来）。&lt;/p&gt;

&lt;h2&gt;关于行动&lt;/h2&gt;

&lt;p&gt;其实不大好意思说“行动”这个词，因为每次给自己定一个计划，大多数情况最后都不了了之了。但是这次，我想说：“我是认真的，因为我意识到了问题的严重性。”&lt;/p&gt;

&lt;p&gt;后面我会每周过来更新下状态，记录下执行情况。虽然我知道这篇文章也不会有几个人看到。毕竟是自己写给自己的。&lt;/p&gt;

&lt;p&gt;----------- 2015-11-23 -----------&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>和PD、运营、设计师和用研们的一顿饭</title>
     <link href="http://korbinzhao.github.io/a-meal-with-colleagues"/>
     <updated>2015-11-16T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/a-meal-with-colleagues</id>
     <content type="html">&lt;p&gt;受PD的邀请，今晚一帮同事去她家做客。去之前，其实心里很是忐忑，自己面对一帮陌生人总会多多少少有些逃避的心理。但是理智告诉我，还是必须得去的，虽然平时工作很忙，经常陷入某个难缠的bug好久，让自己越发的有些寡言少语。一来这不是我想要的状态，二来长此以往是非常不健康的。&lt;/p&gt;

&lt;h2&gt;经过&lt;/h2&gt;

&lt;p&gt;去之前买了点水果带过去，否则空着手去做客太说不过去了。幸好买了，其实大家过去也都多多少少带了些东西，比如水果、红酒。PD家离我住的地方倒也非常近，打了车5分钟就到小区门口了，从小区门口进去一直走，穿过漆黑一片的小路，最近好不容易找到PD的家。&lt;/p&gt;

&lt;p&gt;小区配套挺差的，连个路灯都没开，附近可以吃饭消遣的地方看起来也不多。但是，已进入房间，顿时眼前一亮，装修不同，真的可以给同样的房子带来完全不同的感觉。超大的客厅（把原来的客厅和一个卧室打通连在一起），客厅中间放着沙发、对面是超大的电视屏幕，后面是一张很大的工作长桌，客人多的时候可以用来当做餐桌（当然，这次就是这样做的），房间内到处都是简约却充满文艺气息的装饰品，房子位于顶楼，复式结构，二楼虽然只是楼顶屋檐下面的一点空间，但是布局合理，丝毫没有压抑的感觉，而且还有2个天窗，天气好的时候抬头就可以看到星星。一句话总结，这房子完全像是设计师精心设计过的房子，但是事实上只是房子的主人——另一个PD的设计，果然是一个充满设计师气质的PD。&lt;/p&gt;

&lt;p&gt;晚饭完全有一个帅帅的运营下厨，扬州人，之前还合作过，其实想说我和扬州还有些渊源，后来忍住没说。最后7点半，前前后后到了有十来个人。晚餐超级丰盛，三文鱼、酸菜鱼、蒜蓉油虾、香橙鸡肉沙拉、啤酒红烧肉、红焖茄子、蒜炒白菜、毛豆米、拍黄瓜、焗海蟹、烤鸡翅、各种糕点。。。我只想说城里人真会吃。还没开始吃饭，下厨的运营就开了一瓶红酒，其他人根据自己喜好选择红酒、果汁。席间还尝试了“peng”一下的喝法，就是用一种叫不出名字的国外的白酒兑上雪碧，手掌按住杯口，往桌子上猛地一按，“peng”的一下，然后往酒里撒点盐，一饮而尽。第一次尝试这种喝法，还挺爽的。&lt;/p&gt;

&lt;h2&gt;感想&lt;/h2&gt;

&lt;p&gt;其实呢，之所有有冲动把简单的一顿饭写出来，就是想谈谈感受。在技术团队待久了，每天对着电脑敲代码，需要说话的场景不是很多，再加上技术团队整体在性格上会比较沉闷，在生活品质和乐趣上的追求也没有其他团队那么多。让我这段时间总感觉有些无聊，心情莫名低落，即使好不容易有点时间也宁愿宅着，有一种非常懒散拖延的状态。这种状态于工作、于生活都不是太好的。所以这里提醒下自己，多走出去，多和不同背景、不同岗位的人交流，这不仅有利于拓宽自己的视野，也会让自己更开心一点。正如今天的这次简单的聚会，虽然去之前略感忐忑，去之后却感觉很享受这个过程，每个人仿佛都有着自己独特的故事、自己独特的生活乐趣，这也是我想经历和正在追求的。&lt;/p&gt;

&lt;p&gt;另外，和有趣的人一起，你也会变得有趣。现在的我有点太无聊了，自己都受不了自己。我需要和有趣的人在一起。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Date对象的浏览器兼容性问题</title>
     <link href="http://korbinzhao.github.io/date-cross-browser-safari-chrome"/>
     <updated>2015-11-06T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/date-cross-browser-safari-chrome</id>
     <content type="html">&lt;h2&gt;new Date()、Date.parse()方法在浏览器中的兼容性问题&lt;/h2&gt;

&lt;p&gt;   Date在不同浏览器中对于传入的时间字符串的格式要求是不一样的。比如在chrome浏览器的控制台中输入以下内容，会得到相应结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Date.parse(&#39;2015-11-11 00:00:00&#39;)
//-&amp;gt;1447171200000
Date.parse(&#39;2015/11/11 00:00:00&#39;)
//-&amp;gt;1447171200000
new Date(&#39;2015-11-11 00:00:00&#39;)
//-&amp;gt;Wed Nov 11 2015 00:00:00 GMT+0800 (CST)
new Date(&#39;2015/11/11 00:00:00&#39;)
//-&amp;gt;Wed Nov 11 2015 00:00:00 GMT+0800 (CST)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  可以发现，chrome对于&#39;-&#39;和&#39;/&#39;分割日期的形式都是支持的，能够返回正确的毫秒数或者时间格式。&lt;/p&gt;

&lt;p&gt;  下面在safari浏览器中输入相同内容，查看对应结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Date.parse(&#39;2015-11-11 00:00:00&#39;)
&amp;lt; NaN = $1
&amp;gt; Date.parse(&#39;2015/11/11 00:00:00&#39;)
&amp;lt; 1447171200000 = $2
&amp;gt; new Date(&#39;2015-11-11 00:00:00&#39;)
&amp;lt; Invalid Date = $3
&amp;gt; new Date(&#39;2015/11/11 00:00:00&#39;)
&amp;lt; Wed Nov 11 2015 00:00:00 GMT+0800 (CST) = $4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   可以发现，safari仅对&#39;/&#39;分割日期的形式支持，对&#39;-&#39;分割日期的形式并不支持。&lt;/p&gt;

&lt;p&gt;  通过以上实验，我们可以观察出chrome和safari对于不同格式的时间字符串的支持情况。chrome同时支持&#39;-&#39;和&#39;/&#39;分割日期的时间字符串；safari不支持&#39;-&#39;分割日期的时间字符串。&lt;/p&gt;

&lt;h2&gt;一个简单有效的解决方法&lt;/h2&gt;

&lt;p&gt;  下面是一个比较好的解决方案：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = &quot;2010-03-15 10:30:00&quot;.split(/[- / :]/),
    date = new Date(arr[0], arr[1]-1, arr[2], arr[3], arr[4], arr[5]);

  console.log(date);
  //-&amp;gt; Mon Mar 15 2010 10:30:00 GMT+0000 (GMT Standard Time)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   该方法为先将时间字符串用split方法进行分割拼装为一个数组，再将每个数组的项作为传参传入new Date()方法，从而将不同形式的字符串转换成有效的时间。
   该方法对于所有浏览器生效。&lt;/p&gt;

&lt;h2&gt;参考资料：&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5324178/javascript-date-parsing-on-iphone&quot;&gt;http://stackoverflow.com/questions/5324178/javascript-date-parsing-on-iphone&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>网站分析指标</title>
     <link href="http://korbinzhao.github.io/key-indicator-website-analysis"/>
     <updated>2015-11-01T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/key-indicator-website-analysis</id>
     <content type="html">&lt;h2&gt;1. UV（Unique Vistor）&lt;/h2&gt;

&lt;p&gt;UV是指唯一的访问者。00:00-24:00内相同的UV只被计算一次。&lt;/p&gt;

&lt;h3&gt;网站分析工具如何辨别UV&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;通过服务器
服务器从浏览器接收到的每次请求都会包含IP、请求时间、浏览器版本、操作系统版本等很多信息，服务器可以根据某些共同特征，来判断是否是同一个UV。不过根据IP判断UV并不十分准确，尤其是在公用IP的局域网环境下。&lt;/li&gt;
&lt;li&gt;通过cookie
浏览器第一次访问某个网站服务器时，服务器会给浏览器发送一个cookie，这个cookie会分配给你一个独一无二的编号，并且会记录你访问服务器的信息，例如访问时间、访问的网页、是否登录、登录的账号信息等。当浏览器再一次访问服务器时，服务器获取到cookie，并对里面的信息进行更新，但是给你的编号是不会变的。cookie中拥有相同编号的两个请求会被认定为同一个visitor。这个方法比上一个更精确些，但是在浏览器禁用cookie或者用户经常删除cookie的情况下，这种方式也将失效。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2. PV（Page View）&lt;/h2&gt;

&lt;p&gt;PV（page view），即页面浏览量，或点击量。一个PV指的是一次从网站下载一个页面的请求（A page view or page impression is a request to load a single page of an Internet site.）。&lt;/p&gt;

&lt;h2&gt;3. Bounce Rate&lt;/h2&gt;

&lt;p&gt;Bounce Rate，指的是在对一个页面的所有访问中，只浏览却没有发生任何点击的访问所占的比率。这种跳失一般发生在用户误点跳转链接或是进入网页后发现内容非常不感兴趣时。&lt;/p&gt;

&lt;p&gt;用一个公式来表示Bounce Rate，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Omniture的计算方法：

Bounce Rate = Single Page Visits / Total Visits
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过Bounce Rate存在另一种计算方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Google Analytics等工具的计算方法：

Bounce Rate = Single PV Visits / Total Visits 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Page Visits 和 PV Visits的主要区别在于在用户刷新时，对visits的统计是否会+1. 举例说明，用户进入页面后在没有任何操作情况下，刷新一次页面Page Visits不会+1，而PV就会+1，使得PV变为2.&lt;/p&gt;

&lt;p&gt;这两种计算方法的具体区别详见&lt;a href=&quot;http://www.woshipm.com/operate/83233.html&quot;&gt;网站分析的最基本度量&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;4. 跳失率&lt;/h2&gt;

&lt;p&gt;业界有『exit rate』和『bounce rate』两个概念，其中『exit rate』指该网页是会话中『最后一页』的浏览占此网页总浏览量的百分比，而『bounce rate』是指该网页是会话中“唯一网页”的会话占从此网页开始的所有会话的百分比。&lt;/p&gt;

&lt;h2&gt;PS：&lt;/h2&gt;

&lt;p&gt;当然，以上这些概念只是行业通用的一些行业，有些甚至没有统一的界定和标准。每个公司都有自己的一套界定规范。如果你是身在职场的孩子，不妨详细了解下本公司对各网站分析指标的详细界定。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>原生JS实现页面滚动方向检测</title>
     <link href="http://korbinzhao.github.io/js-scroll-direction"/>
     <updated>2015-10-27T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/js-scroll-direction</id>
     <content type="html">&lt;p&gt;判断页面滚动方向是一个常见的需求，下面展示一个使用原生JS方式判断页面滚动方向的解决方式。&lt;/p&gt;

&lt;h2&gt;html&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://g.tbcdn.cn/tb/kimi/0.0.233/kimi.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;body style=&quot;height: 6000px;&quot;&amp;gt;
    &amp;lt;div class=&quot;nav&quot; style=&quot;position:fixed; top:0;left:0;width: 100%;height: 60px;background-color: pink;&quot;&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;js&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  var $nav = $(&#39;.nav&#39;);
  var $result = $(&#39;.result&#39;);

  //页面滚动监听事件
  window.onscroll = function(e){
    $result.html(&#39;swipeDown&#39;);
    scrollFunc();
    if(scrollDirection == &#39;down&#39;){
      $nav.css({
        position: &#39;absolute&#39;
      });
    }
    else if(scrollDirection == &#39;up&#39;){
      $nav.css({
        position: &#39;fixed&#39;
      });
    }
  }
  var scrollAction = {x: &#39;undefined&#39;, y: &#39;undefined&#39;}, scrollDirection;

  //判断页面滚动方向
  function scrollFunc() {
    if (typeof scrollAction.x == &#39;undefined&#39;) {
      scrollAction.x = window.pageXOffset;
      scrollAction.y = window.pageYOffset;
    }
    var diffX = scrollAction.x - window.pageXOffset;
    var diffY = scrollAction.y - window.pageYOffset;
    if (diffX &amp;lt; 0) {
    // Scroll right
      scrollDirection = &#39;right&#39;;
    } else if (diffX &amp;gt; 0) {
    // Scroll left
      scrollDirection = &#39;left&#39;;
    } else if (diffY &amp;lt; 0) {
    // Scroll down
      scrollDirection = &#39;down&#39;;
    } else if (diffY &amp;gt; 0) {
    // Scroll up
      scrollDirection = &#39;up&#39;;
    } else {
    // First scroll event
    }
    scrollAction.x = window.pageXOffset;
    scrollAction.y = window.pageYOffset;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;github地址&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/korbinzhao/exercise/blob/master/js-scroll-direction.html
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>前端模块化规范 - CommonJS、AMD & CMD</title>
     <link href="http://korbinzhao.github.io/commonjs-amd-cmd"/>
     <updated>2015-10-25T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/commonjs-amd-cmd</id>
     <content type="html">&lt;p&gt;前端为什么会出现模块化这个概念，主要原因是随着前端项目的复杂性和项目团队规模的扩大，命名冲突和文件依赖成为影响前端开发效率的两个重要问题。模块化规范的另一个目的是提高JS程序的可移植性。&lt;/p&gt;

&lt;h2&gt;CommonJS&lt;/h2&gt;

&lt;p&gt;官方JavaScript规范定义的API主要是为了构建基于浏览器端的应用程序。在服务器端，并没有官方的API定义。&lt;/p&gt;

&lt;p&gt;CommonJS定义了许多普通应用程序（主要指非浏览器应用）使用的API，它的终极目标是提供一个类似Python、Ruby和Java的标准库，从而开发者可以使用CommonJS API编写可以运行在不同JS解释器和不同主机环境的应用程序。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;NodeJS和CommonJS之间的关系&lt;/p&gt;

&lt;p&gt;  CommonJS是一种规范，NodeJS是这种规范的实现。JavaScript作为本地变成语言这种特殊应用程序，也是随着NodeJS的火热而进入大众的视野。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;浏览器加载 CommonJS 模块的原理与实现&lt;/p&gt;

&lt;p&gt;  npm的模块都是JS语言写的，但是浏览器用不了，因为浏览器不支持CommonJS格式。要想让浏览器用上这些模块，必须转换格式。&lt;/p&gt;

&lt;p&gt;  浏览器不兼容CommonJS的根本原因，在于缺少四个Node.js环境的变量。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  module
  exports
  require
  global
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  只要能够提供这四个变量，浏览器就能加载CommonJS模块。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Browserify的实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;知道了原理，就能做出工具了。Browserify（require(&#39;modules&#39;) in the browser）是目前最常用的CommonJS格式转换的工具。&lt;/p&gt;

&lt;p&gt;举例：
main.js模块加载foo.js模块&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// foo.js
module.exports = function(x) {
  console.log(x);
};

// main.js
var foo = require(&quot;./foo&quot;);
foo(&quot;Hi&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用下面的命令，就能将main.js转为浏览器可用的格式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ browserify main.js &amp;gt; compiled.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Browserify到底做了什么？安装一下browser-unpack，就能看清楚了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm install browser-unpack -g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，将前面生成的compile.js解包。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ browser-unpack &amp;lt; compiled.js

[
  {
    &quot;id&quot;:1,
    &quot;source&quot;:&quot;module.exports = function(x) {\n  console.log(x);\n};&quot;,
    &quot;deps&quot;:{}
  },
  {
    &quot;id&quot;:2,
    &quot;source&quot;:&quot;var foo = require(\&quot;./foo\&quot;);\nfoo(\&quot;Hi\&quot;);&quot;,
    &quot;deps&quot;:{&quot;./foo&quot;:1},
    &quot;entry&quot;:true
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，browerify将所有模块放入一个数组，id属性是模块的编号，source属性是模块的源码，deps属性是模块的依赖。&lt;/p&gt;

&lt;p&gt;因为main.js里面加载了foo.js，所以deps属性就制定./foo对应的1号模块。执行的时候，浏览器遇到require(&#39;./foo&#39;)语句，就自动执行1号模块的source属性，并就爱那个执行后的module.exports属性值输出。&lt;/p&gt;

&lt;h2&gt;AMD&lt;/h2&gt;

&lt;p&gt;AMD（异步模块定，Asynchronous Module Definition）格式总体的目标是为现在的开发者提供一个可用的模块化JS解决方案。&lt;/p&gt;

&lt;p&gt;CommonJS通过引入模块化使得在服务器端编写JS应用成为可能，但是由于一个重大的局限，使得CommonJS规范不适用与浏览器环境。举例如下。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var math = require(&#39;math&#39;);
　　math.add(2, 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二行math.add(2, 3)，在第一行require(&#39;math&#39;)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。&lt;/p&gt;

&lt;p&gt;这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这确实一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于“假死”状态。&lt;/p&gt;

&lt;p&gt;因此，浏览器端的模块，不能采用“同步加载”（synchronous），只能采用“异步加载”（asynchronous）。这就是AMD规范诞生的背景。&lt;/p&gt;

&lt;p&gt;AMD是“Asynchronous Module Definition”的缩写，意思就是“异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。&lt;/p&gt;

&lt;p&gt;AMD也采用require()语句加载模块，但是不同于CommonJS，他要求两个参数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require([module], callback);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。&lt;/p&gt;

&lt;h2&gt;CMD&lt;/h2&gt;

&lt;p&gt;CMD（Common Module Definition）模块定义规范，是@玉伯提出的一个类似于AMD的规范，该规范明确了模块的基本书写格式和基本交互规则。&lt;/p&gt;

&lt;h3&gt;AMD和CMD的区别&lt;/h3&gt;

&lt;p&gt;下面来看下@玉伯给出的官方解释。&lt;/p&gt;

&lt;p&gt;AMD和CMD等规范的目的都是为了JS的模块化开发，特别是在浏览器端的。目前这些规范的实现都能达成浏览器端模块化开发的目的。&lt;/p&gt;

&lt;p&gt;区别在于：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;对于依赖的模块，AMD是提前执行，CMD是延迟执行。不过RequireJS从2.0开始，也改成了可以延迟执行（根据写法不同，处理方式不同）。CMD推崇as lazy as possible。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CMD推崇依赖就近，AMD推崇依赖前置。如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; // CMD
 define(function(require, exports, module) {   
     var a = require(&#39;./a&#39;)   
     a.doSomething()   
     // 此处略去 100 行   
     var b = require(&#39;./b&#39;) // 依赖可以就近书写   
     b.doSomething()   
     // ... 
 })

 // AMD 默认推荐的是
 define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) {  
     // 依赖必须一开始就写好    
     a.doSomething()    
     // 此处略去 100 行    
     b.doSomething()    
     ...
 })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt; 虽然AMD也支持CMD的写法，同时还支持require作为依赖项传递，但RequireJS官方文档里默认上面的模块定义写法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;AMD的API默认是一个当多个用，CMD的API严格区分，推崇职责单一。比如AMD里，require分全局require和局部require，都叫require。CMD里，没有全局require，而是根据模块系统的完备性，提供seajs.use来实现模块系统的加载启动。CMD里，每个API都简单纯粹。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/fullhouse/archive/2011/07/15/2107416.html&quot;&gt;什么是CommonJS？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.feeldesignstudio.com/2013/09/javascript-module-pattern-commonjs/&quot;&gt;JavaScript模块化开发（二）——CommonJS规范&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/05/commonjs-in-browser.html&quot;&gt;浏览器加载 CommonJS 模块的原理与实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html&quot;&gt;Javascript模块化编程（二）：AMD规范&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.zhihu.com/question/20351507&quot;&gt;AMD 和 CMD 的区别有哪些？- 知乎&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>JS跨域问题解决方式</title>
     <link href="http://korbinzhao.github.io/cross-origin-js"/>
     <updated>2015-10-23T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/cross-origin-js</id>
     <content type="html">&lt;p&gt;所谓跨域，或者异源，是指主机名（域名）、协议、端口号只要有其一不同，就为不同的域（或源）。浏览器中有一个基本的策略，叫同源策略，即限制“源”自A的脚本只能操作“同源”页面的DOM。以下列举几种跨域方式。&lt;/p&gt;

&lt;h2&gt;1.CORS&lt;/h2&gt;

&lt;p&gt;Cross-Origin Resource Sharing，跨域资源共享，简称 CORS。CORS系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。跨域资源共享是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。&lt;/p&gt;

&lt;p&gt;CORS(Cross-Origin Resource Sharing,􏰛源􏰉源共􏰠)是 W3C 的一个工作􏰡案,定义了在必须访问跨源资源时,浏览器与服􏰁务器应该如何􏰢沟通。CORS背􏰣后的基本思想,就是使用自定义的HTTP头部让浏览器与服􏰁务器进行沟􏰢通,从而决定请求或响应是应该成功,还是应该失败。&lt;/p&gt;

&lt;p&gt;具体如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个简单的使用GET或POST发􏰀的请求,它没有自定义的头部,而主体内容是text/plain。在发送􏰀该请求时,需要给它􏰤加一个􏰥额外的Origin头部,其中包含请求􏰝面的源信息(协􏰦议、域名和􏰧端口),以便服􏰁务器根据这个头部信息来决定是否给予响应。下面是 Origin 头部的一个示例:&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt; 消费者发送一个Origin报头到提供者端：Origin: http://www.a.com；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;提供者发送一个Access-Control-Allow-Origin响应报头给消费者，如果值为“*”或Origin对应的站点，则表示同意共享资源给消费者，如果值为null或者不存在Access-Control-Allow-Origin报头，则表示不同意共享资源给消费者；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果没有这个头部,或者有这个头部但源信息不匹配,浏览器就会驳􏰩回请求。正常情况下,浏览器会处理请求&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;注：CORS支持GET/POST请求方式&lt;/p&gt;

&lt;h2&gt;2.JSONP&lt;/h2&gt;

&lt;p&gt;JSONP 是 JSON with padding(填充式 JSON 或参数式 JSON)的简写。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;callback({ &quot;name&quot;: &quot;Nicholas&quot; });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于一段JavaScript脚本来说，其“源”与它存储的地址无关，而取决于脚本被加载的页面，例如我们在页面中使用script引入存储在其他域的脚本文件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://www.a.com/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里脚本与当前页面是同源的。除了script，还有img、iframe、link等都具有跨域加载资源的能力。&lt;/p&gt;

&lt;p&gt;Jsonp正是利用这种特性来实现跨域的：在页面中引入要跨域访问的来源，并定义回调函数处理跨域访问得到的json数据。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var script = document.createElement(&quot;script&quot;);
  script.src = &quot;http://freegeoip.net/json/?callback=handleResponse&quot;;
  document.body.insertBefore(script, document.body.firstChild);

  function handleResponse(response){
    console.log(&quot;You are at IP address &quot; + response.ip + &quot;, which is in &quot; +
        response.city + &quot;, &quot; + response.region_name);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：JSONP只支持GET请求方式&lt;/p&gt;

&lt;h2&gt;3.修改document.domain来跨子域&lt;/h2&gt;

&lt;p&gt;www.a.com/1.html和a.com/2.html是不同域的，要使他们可以跨域访问，可通过修改document.domain来实现，即在两个页面中都设置：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;document.domain=&quot;a.com&quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是document.domain只能往父级修改，如a.com改为www.a.com是不被允许的，这也是此方法的局限性，只使用于跨子域访问。&lt;/p&gt;

&lt;h2&gt;4.使用window.name来跨域访问&lt;/h2&gt;

&lt;p&gt;window.name是同一浏览器窗口下载入的所有页面共享的数据字段，所有窗口都可以读写此字段的内容。&lt;/p&gt;

&lt;p&gt;所以假设a.com要访问b.com的数据，只需要在b.com中将数据放在window.name中，然后a.com从中取出即可。此方法适用于像iframe这样的嵌套页面架构。&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://segmentfault.com/a/1190000003784372&quot;&gt;浅谈js跨域问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;JavaScript高级程序设计&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>入职了，转正了</title>
     <link href="http://korbinzhao.github.io/become-a-regular-worker"/>
     <updated>2015-10-23T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/become-a-regular-worker</id>
     <content type="html">&lt;p&gt;正式入职3个月，经过了转正面试，接连有了两次转正后的交流会。今晚这次交流比较有感触，所以特别记一下。&lt;/p&gt;

&lt;p&gt;前两天，团队新近的6个新人全部转正面试结束。老板ZY把我们同组的6个人叫到一起，开了个简单的交流会。此前的转正面试加上最近2次交流会，有一些收获，记录一下，给以后工作中的自己提个醒。&lt;/p&gt;

&lt;h2&gt;从业务中抽离出来做些自己的事情&lt;/h2&gt;

&lt;p&gt;我们的日常业务是很忙的。要学会从繁重的业务中抽身出来，去做些个人成长、技术成长的事情。说白了，只做业务的话说实话，最后只是简单一些重复劳动，如果不能自己抽出时间进行学习、积累的话，自己很难会有成长，对于之后的KPI考核、薪酬、晋升其实是没有什么好处的。&lt;/p&gt;

&lt;p&gt;这一点是自从入职后，每次开交流会团队老大YX和HR都会返回强调的。只做业务，没有自己的核心竞争力的话，个人的不可替代性就太强了，对于团队的价值就非常小。&lt;/p&gt;

&lt;h2&gt;工作中思考&lt;/h2&gt;

&lt;p&gt;思考是工作中非常重要的一个能力，不能在工作中有自己的思考，那么你就只能是别人眼中的一个工具。这里的思考既有对前端团队内部效率、工具的思考，也有对自己所负责业务的思考。&lt;/p&gt;

&lt;h2&gt;将自己的思考写出来&lt;/h2&gt;

&lt;p&gt;一些事情自己能想到以及想清楚和真正把想法写出来是完全两种不同的概念。很多时候，我们只是自我感觉把有些东西想清楚了，但是真的当我们需要临场表达的时候常常是毫无逻辑、丢三落四或者混乱不堪的。这说明我们还没有把自己的思路真正的理清楚。那么，平时自己有所思考的时候，把自己的想法写出来吧！&lt;/p&gt;

&lt;p&gt;写作可以让你对自己的过往的思考有一个清晰的回顾和整理，并且当我们回过头来看自己的过往的想法时也是一种意义非法的事情。&lt;/p&gt;

&lt;h2&gt;拓展自己的舒服边界-团队中的充分交流&lt;/h2&gt;

&lt;p&gt;作为一个资深的、被很多人认为很内向的人，在面对长辈和领导时总是会有一种莫名的紧张，会表现的很内向，这个毛病伴随了我20+年。&lt;/p&gt;

&lt;p&gt;要解决这个问题，用今天ZY的一句话来说，就是要拓展自己的舒服边界。每个人都有自己的舒服边界，有的人舒服边界大一些，则表现出来就外向一点，有的人舒服边界小一些，则表现出来就内向一点。&lt;/p&gt;

&lt;p&gt;没办法，平时不能太懒，要多花点时间和团队其他成员交流。&lt;/p&gt;

&lt;p&gt;能想到的一个比较好的方式，&lt;strong&gt;就是在自己迟疑要不要说某句话或者和某人交流的时候，放弃迟疑，果断迈出第一步吧。&lt;/strong&gt;改变是一点点发生的。&lt;/p&gt;

&lt;h2&gt;将自己的实力充分表现出来&lt;/h2&gt;

&lt;p&gt;最后一点感触很深的是，无论你多牛掰，不表现出来，不让你身边的人、老版、HR看到，一切都是白搭的。所以工作中很苦逼的一种状态会是，你每天累得像孙子一样，老板却看不到你的实力、成果。&lt;/p&gt;

&lt;p&gt;所以，适时的把自己的实力、观点表达出来吧~&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
