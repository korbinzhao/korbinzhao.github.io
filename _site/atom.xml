<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>Joebon's world</title>
   <link href="http://joebon.cc/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://joebon.cc" rel="alternate" type="text/html" />
   <updated>2016-04-28T09:55:09+08:00</updated>
   <id>http://joebon.cc</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>嗯，植发了</title>
     <link href="http://korbinzhao.github.io/hair-transplant"/>
     <updated>2016-04-28T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/hair-transplant</id>
     <content type="html">&lt;h2&gt;岁月是把杀猪刀&lt;/h2&gt;

&lt;p&gt;26岁就面临头发越来越少、额头越来越的境遇，森森的忧桑。小时候长得精致的我，看着一天天、一年年变丑的自己，领会到岁月是把杀猪刀的道理。&lt;/p&gt;

&lt;p&gt;先谈谈自己的脱发史吧，高中上学那会儿，可能因为压力大的原因，就发现头很油、头发很容易掉的问题，不过年纪轻嘛，也没往这方面想。大一大二头发都还挺正常的，到了大三、大四，突然发现自己头发好像留不长了，发型也变得越来越不好看。研究生阶段，整个问题就越发明显了。从脱发开始明显显现到现在也有5年的时间了。这段时间里，脱发也成为了最困扰自己的一个问题。&lt;/p&gt;

&lt;p&gt;了解植发，是从去年开始的。之前去普通医院、皮肤医院都看过，给出的结论基本都是脂溢性脱发，药物治疗只有米诺地尔和非那雄胺比较有效。不过听说非那雄胺会对性功能产生影响，所以一直没敢用。之前用过大概3个月的米诺地尔，因为不了解的原因，主要用在了前额上，现在想想是完全徒劳无功的，因为前额的毛囊基本已经坏死了。当初如果用在头顶部的话，现在应该也会有点效果了。总之，用了一段时间的米诺地尔，一是太麻烦，二是使用位置不对，没啥效果，后来就没坚持下来。大概一年前，去了一家植发机构，大概了解了植发的原理、技术细节和价格。后来一是因为忙，二是不知道哪家植发机构靠谱，这个事情也就耽搁了下来。&lt;/p&gt;

&lt;h2&gt;决定植发了&lt;/h2&gt;

&lt;p&gt;作为外貌协会会员，对自己的形象还是很在意的。有时照一眼镜子，可能影响一天的心情。这个心结其实让我在了解植发之初，就已经决定要走植发这条路了。不过一直迟迟没有做植发的一个重要原因是不知道如何去选择一家靠谱的植发机构。可能是因为里面广告贴比较多的原因吧，我不太相信植发论坛里的帖子，也没怎么逛过植发论坛。主要了解植发技术和植发机构的渠道是知乎，还有就是亲身的考察。今年4月份，我在网上了解的基础上看了2家杭州的植发机构。通过对比，发现技术、价格上其实都差不多。再加上，中间认识到一位做过植发的本科师兄，了解了他的植发经历，也看了植发一年后的效果。最终确定在师兄做植发的这家机构做植发手术。时间就定在我实地考察2家医院的3周后——2016.04.23。&lt;/p&gt;

&lt;h2&gt;手术进行中&lt;/h2&gt;

&lt;p&gt;“铃铃铃~~~”，谁大早上的打电话？“*先生，你在路上了吗？”。。我擦，睡过头了。。&lt;/p&gt;

&lt;p&gt;好吧，这就是我手术当天的开始~ 史无前例高效的洗刷、穿衣、打车，还是晚了一个多小时才到医院。好在咨询医生人超好的帮我推迟了时间，还替我买了早餐。。只能说服务太周到了。与此同时，陷入2个闹钟都没被叫醒的深深自责中。。&lt;/p&gt;

&lt;p&gt;手术开始前，先剃了个板寸，也就剩一两毫米吧。然后洗了头，画了发际线，进入手术室。&lt;/p&gt;

&lt;p&gt;手术分为前后2个阶段，第一个阶段：取发；第二个阶段：植发。取发3个半小时，出来已经下午2点了。吃了饭，休息了大概半个多小时，重新进入手术室，进行下半程植发，一直到晚上8点半才结束，之前预测的手术时间在4、5个小时上，没想到这么久，据说是因为我自然卷的原因，取发比较慢，医生和我都累坏了。剩最后100单位的时候，还出现了个小意外，居然停电了，最后是在2部手机闪光灯的照射下完成了最后阶段的手术。&lt;/p&gt;

&lt;p&gt;手术过程中，最痛苦的过程是打麻药的过程。由于是局部麻醉，要覆盖到所有的取发区和植发区，所以光打麻药就被扎了几十针。在靠近耳朵和鬓角的位置，打麻药是非常疼的，因为神经比较集中。麻药生效后，头皮就感觉不是自己的了，所以一天被扎了几千针也没有什么特别的痛感。&lt;/p&gt;

&lt;p&gt;躺了一天，中间也不知道睡了醒，醒了睡反复了几次，最终手术宣告结束，植发3300+单位。&lt;/p&gt;

&lt;h2&gt;术后当晚&lt;/h2&gt;

&lt;p&gt;手术后已经接近晚上九点了，医院提供免费的住宿和饮食，就索性住下了。这里插一句，医院的服务和医生、护士的态度真的很好。他们的工作氛围也非常轻松愉快，还挺羡慕他们这种工作的感觉的。&lt;/p&gt;

&lt;p&gt;可能是因为做了鬓角的原因，当晚右前额+右眼，很疼，吃了止痛药也没啥作用。就是觉得又疼又困，后来迷迷糊糊很早就睡了。&lt;/p&gt;

&lt;h2&gt;术后前三天&lt;/h2&gt;

&lt;p&gt;到了术后第一天中午时分的样子，疼痛的感觉基本消除了。一夜不能翻身，枕着医院提供的U型枕睡了一晚，一个动作保持到天亮还挺累的。上午和住在一个房间的发友、护士聊聊天，下午换了纱布，在病房睡了一觉，然后就打道回府了。&lt;/p&gt;

&lt;p&gt;术后第二天，请假在家休养了一天。照镜子发现自己额头有三块地方明显陷进去了，而且是很明显的那种。回想一下，是手术过程中有医生一直负责用手指摁住我的额头的原因。当时心想，难不成以后就一直陷进去了，这医生指力如此过人，一看就不是俗人。第四天再看，凹陷已经完全恢复了，想想可能是因为水肿的原因。第三四天的时候，头顶明显发痒，一度有是在忍不住想去挠的冲动，还好忍住了。后来咨询医生，说是正常现象。痒了大概一两天，现在已经没啥感觉了。&lt;/p&gt;

&lt;p&gt;术后一堆要注意的事情，医生都会交代。主要是饮食、活动、洗头等方面的注意点。&lt;/p&gt;

&lt;p&gt;当前时间是术后第四天，简单谈谈自己感受。植发手术虽然是个简单微创手术，但是整个过程还是有点遭罪的。医院的医生护士服务态度都超级好，这点让我小感动，这也是最终选择这家医院的一个重要原因。目前来说效果还为时尚早，后续每隔一段时间更新下自己的状况吧。为自己记录下这次经历，也为同病相怜者提供一点借鉴。&lt;/p&gt;

&lt;p&gt;----------------------华丽丽的分割线，目前是术后第四天-----------------------&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>nodejs 中间件 & 插件</title>
     <link href="http://korbinzhao.github.io/middleware&plugins"/>
     <updated>2016-04-05T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/middleware&plugins</id>
     <content type="html">&lt;h2&gt;中间件&lt;/h2&gt;

&lt;p&gt;中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或 OS 环境。例如：IBM MQSeries，CICS/TXSeries&lt;/p&gt;

&lt;h3&gt;如何理解 &quot;中间件&quot; ?&lt;/h3&gt;

&lt;p&gt;我的理解是这样的，中间件就是类似于一个过滤器的东西，在客户端和应用程序之间的一个处理请求和响应的的方法。&lt;/p&gt;

&lt;p&gt;如果把一个http处理过程比作是污水处理，中间件就像是一层层的过滤网。每个中间件在http处理过程中通过改写request或（和）response的数据，状态，实现了特定的功能。&lt;/p&gt;

&lt;p&gt;以 koa 中间件为例：&lt;/p&gt;

&lt;p&gt;Koa的中间件很像Express的中间件，也是对HTTP请求进行处理的函数，但是必须是一个Generator函数。而且，Koa的中间件是一个级联式（Cascading）的结构，也就是说，属于是层层调用，第一个中间件调用第二个中间件，第二个调用第三个，以此类推。上游的中间件必须等到下游的中间件返回结果，才会继续执行，这点很像递归。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var koa = require(&#39;koa&#39;);
var http = require(&#39;http&#39;);
var app = koa();

app.use(function *(next){
 console.log(&#39;&amp;gt;&amp;gt; one&#39;);
 yield next;
 console.log(&#39;&amp;lt;&amp;lt; one&#39;);
});

app.use(function *(next){
 console.log(&#39;&amp;gt;&amp;gt; two&#39;);
 this.body = &#39;two&#39;;
 yield next;
 console.log(&#39;&amp;lt;&amp;lt; two&#39;);
});

app.use(function *(next){
  console.log(&#39;&amp;gt;&amp;gt; three&#39;);
  yield next;
  console.log(&#39;&amp;lt;&amp;lt; three&#39;);
});

http.createServer(app.callback()).listen(3000);

console.log(&#39;server start at port 3000&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;插件&lt;/h2&gt;

&lt;p&gt;插件是一种遵循一定规范的应用程序接口编写出来的程序。很多软件都有插件，插件有无数种。例如在IE中，安装相关的插件后，WEB浏览器能够直接调用插件程序，用于处理特定类型的文件。IE浏览器常见的插件例如：Flash插件、RealPlayer插件、MMS插件、MIDI五线谱插件、ActiveX插件等等；再比如Winamp的DFX，也是插件。还有很多插件都是程序员新开发的。&lt;/p&gt;

&lt;h2&gt;组件&lt;/h2&gt;

&lt;p&gt;组件和插件的区别是，插件是属于程序接口的程序，组件在ASP中就是控件、对象，ASP/IIS的标准安装提供了11个可安装组件。ASP的FSO组件，编程的朋友都如雷贯耳吧，它就是最常用的Scripting.FileSystemObject对象。&lt;/p&gt;

&lt;h2&gt;套件&lt;/h2&gt;

&lt;p&gt;套件（package）Java提供package机制 ，它就像是一个管理容器，可以将您所定义的名称区隔管理在package下，而不会有相互冲突的发生，例如您定义了一个dimension2d与dimension3d的package，在它们之下都有一个Point类别，但由于属于不同的package，所以这两个名称并不会有所冲突。&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/bigbearbb/p/4221378.html&quot;&gt;大熊君大话NodeJS之------Connect中间件模块（第一季）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/enshrineZither/p/4093872.html&quot;&gt;中间件、插件、组件、套件之间的差别&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>字符编码扫盲及escape, encodeURI 和 encodeURIComponent方法比较</title>
     <link href="http://korbinzhao.github.io/comparing-escape-encodeURI-and-encodeURIComponent"/>
     <updated>2016-01-20T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/comparing-escape-encodeURI-and-encodeURIComponent</id>
     <content type="html">&lt;h2&gt;字符编码：ASCII，Unicode和UTF-8&lt;/h2&gt;

&lt;p&gt;在正式说转码之前，先了解下字符编码。下面是阮一峰网络日志的一篇文章的摘抄。&lt;/p&gt;

&lt;h3&gt;1.ASCII码&lt;/h3&gt;

&lt;p&gt;在计算机内部，所有的信息都最终表示为一个二进制字符串。每一个二进制（bit）有0和1两种状态，一个字节由8个二进制位组成，所以共256(2&lt;sup&gt;8&lt;/sup&gt;)种状态。&lt;/p&gt;

&lt;p&gt;ASCII码是定义了英文字符和二进制位之间关系的字符编码。ASCII码一共规定了128个字符的编码，比如空格是32（二进制00100000）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后7位，最前面一位统一规定为0；&lt;/p&gt;

&lt;h3&gt;2.非ASCII编码&lt;/h3&gt;

&lt;p&gt;英文用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。&lt;/p&gt;

&lt;p&gt;但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。&lt;/p&gt;

&lt;p&gt;至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。&lt;/p&gt;

&lt;h3&gt;3.Unicode&lt;/h3&gt;

&lt;p&gt;正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。&lt;/p&gt;

&lt;p&gt;可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字表示的，这是一种所有符号的编码。&lt;/p&gt;

&lt;p&gt;Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样。&lt;/p&gt;

&lt;h3&gt;Unicode的问题&lt;/h3&gt;

&lt;p&gt;需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。&lt;/p&gt;

&lt;p&gt;比如，汉字&quot;严&quot;的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。&lt;/p&gt;

&lt;p&gt;这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。&lt;/p&gt;

&lt;p&gt;它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。&lt;/p&gt;

&lt;p&gt;转码问题是一个经常让人头疼的问题，下面比较下escape(), encodeURI() 和 encodeURIComponent()三种方法的不同以及使用场景。&lt;/p&gt;

&lt;h3&gt;5.UTF-8&lt;/h3&gt;

&lt;p&gt;互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。&lt;/p&gt;

&lt;p&gt;UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。&lt;/p&gt;

&lt;p&gt;UTF-8的编码规则很简单，只有二条：&lt;/p&gt;

&lt;p&gt;1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。&lt;/p&gt;

&lt;p&gt;2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
下表总结了编码规则，字母x表示可用编码的位。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Unicode符号范围(十六进制) | UTF-8编码方式（二进制）
--------------------|------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。&lt;/p&gt;

&lt;h2&gt;escape(), encodeURI() 和 encodeURIComponent()方法比较&lt;/h2&gt;

&lt;h3&gt;escape()方法&lt;/h3&gt;

&lt;p&gt;escape方法返回一个Unicode格式的字符串。所有的空格、标点符号、特殊字符和其他非ASCII字符都会被替换为%xx格式的编码，其中xx是相应字符的16进制数字。比如，一个空格会被转码为&quot;%20&quot;。&lt;/p&gt;

&lt;p&gt;该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： - _ . ! ~ * &#39; ( ) 。其他所有的字符都会被转义序列替换。&lt;/p&gt;

&lt;h3&gt;encodeURI()方法&lt;/h3&gt;

&lt;p&gt;encodeURI() 函数可把字符串作为 URI 进行编码。某些字符将被十六进制的转义序列进行替换。&lt;/p&gt;

&lt;p&gt;该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * &#39; ( ) 。&lt;/p&gt;

&lt;p&gt;该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;amp;=+$,#&lt;/p&gt;

&lt;p&gt;注：
decodeURI(undefined) === &#39;undefined&#39;; //true&lt;/p&gt;

&lt;h3&gt;encodeURIComponent()方法&lt;/h3&gt;

&lt;p&gt; encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt; 通过对三个函数的分析，我们可以知道：escape()除了 ASCII 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对URL编码，最好不要使用此方法。而encodeURI() 用于编码整个URI,因为URI中的合法字符都不会被编码转换。encodeURIComponent方法在编码单个URIComponent（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个URL。&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot;&gt;字符编码笔记：ASCII，Unicode和UTF-8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://xkr.us/articles/javascript/encode-compare/&quot;&gt;Comparing escape(), encodeURI(), and encodeURIComponent()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/qiantuwuliang/archive/2009/07/19/1526687.html&quot;&gt;escape()、encodeURI()、encodeURIComponent()区别详解&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>模拟form表单上传图片</title>
     <link href="http://korbinzhao.github.io/upload-image-simulate-post-form"/>
     <updated>2016-01-17T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/upload-image-simulate-post-form</id>
     <content type="html">&lt;p&gt;浏览器端：
html：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;form id=&quot;fileupload&quot; class=&quot;fileupload form-upload&quot; style=&quot;display:none;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;javascript:;&quot; role = &quot;form&quot;&amp;gt;\
    &amp;lt;input type = &quot;file&quot; name = &quot;files&quot; class=&quot;file-input&quot; /&amp;gt; \
    &amp;lt;input type=&quot;hidden&quot; name=&quot;modulename&quot; value=&quot;&quot;/&amp;gt;\
    &amp;lt;input type=&quot;button&quot; class=&quot;upload-btn J_Uploadimg&quot;  value=&quot;上传截图&quot;/&amp;gt;\
&amp;lt;/form&amp;gt;\
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $fileUpload = $(&quot;.fileupload&quot;);

var formData = new FormData($fileUpload[0]);

    $.ajax({
        url: &#39;/api/upload_img&#39;,
        type: &#39;POST&#39;,   
        data: formData,
        async: false,
        cache: false,
        contentType: false,
        processData: false,
        success: function(data){
            nanobar.go(100);
            //异步化
            if(data.success){
                $(&#39;#J_MsgCenter&#39;).html($.substitute(&#39;&amp;lt;span class=&quot;label label-success&quot;&amp;gt;{message}&amp;lt;/span&amp;gt;&#39;,{message:data.message}));
            }
            else{
                $(&#39;#J_MsgCenter&#39;).html($.substitute(&#39;&amp;lt;span class=&quot;label label-danger&quot;&amp;gt;{message}&amp;lt;/span&amp;gt;&#39;,{message:data.message}));
            }   
            node.removeClass(&#39;disabled&#39;);
            if(node.attr(&#39;data-reload&#39;)){
                window.location.reload();
            }
            console.log(&#39;imgUploader upload success, data:&#39;, data);
        },
        error: function(){
            $(&quot;#spanMessage&quot;).html(&quot;与服务器通信发生错误&quot;);
        }
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器端：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function (req, res, next) {

new Promise(function(resolve, reject){

res.append(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);

var form = new multiparty.Form();

form.parse(req, function(err, fields, files) {

  console.log(&#39;fields:&#39;);
  console.log(fields);

  console.log(&#39;files:&#39;);
  console.log(files);

  var modulename = fields.modulename[0];

  var modulePath = path.join(work_path, &#39;module&#39;, modulename);
  var imgPath = files.files[0].path;

  uploadImg(imgPath, modulePath, resolve, reject);

});

})
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>剪切板粘贴上传图片功能的实现</title>
     <link href="http://korbinzhao.github.io/clipboard-image-upload"/>
     <updated>2016-01-17T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/clipboard-image-upload</id>
     <content type="html">&lt;p&gt;平时的开发中我们难免要上传一些网页截图，传统的选择文件上传使用起来不方便，这里介绍一种使用js和node实现的剪切板黏贴上传图片功能。当我们需要上传截图时，只需手动截图后commond/ctrl+v即可完成图片上传。这种方式将大大减少我们在上传图片过程中花费的时间。&lt;/p&gt;

&lt;p&gt;要实现剪切板黏贴上传功能，首先我们要先能获取到在剪切板中的图片，这里给大家介绍一个很好用的js插件：&lt;a href=&quot;https://github.com/jorgenbs/ImageClipboard&quot;&gt;ImageClipboard&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;ImageClipboard&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jorgenbs/ImageClipboard&quot;&gt;ImageClipboard&lt;/a&gt;是一款在chrome、firefox和opera上有效的可以将剪切板中的图片黏贴到网页上的工具。&lt;/p&gt;

&lt;h3&gt;安装&lt;/h3&gt;

&lt;p&gt;可以使用bower很简单的安装，如果没有安装bower，请先安装bower,安装使用说明见：&lt;a href=&quot;http://javascript.ruanyifeng.com/tool/bower.html&quot;&gt;bower：客户端库管理工具&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bower install image-clipboard
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;使用：将剪切板中的图片黏贴到网页中去&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;ImageClipBoard.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;

 var clipboard = new ImageClipboard(&#39;#box&#39;, function (base64) {
    //do stuff with pasted image
 });

  //onpaste-callback can also be passed as second argument
  //in the constructor above.
 clipboard.onpaste = function (base64) {
    //do stuff with the pasted image
  });

  //you can also pass in single DOM-element instead of 
  //query as the first parameter.

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  运行以上代码后，div#box中会插入一个img标签，src即为当前剪切板中图片。&lt;/p&gt;

&lt;h2&gt;剪切板中图片的获取与上传&lt;/h2&gt;

&lt;p&gt;通过ImageClipboard，我们可以以base64的形式获取到剪切板中的图片，然后将base64数据作为参数通过POST的方式传输到服务器端。&lt;/p&gt;

&lt;h3&gt;浏览器端代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;this.props.clipboard.onpaste = function (base64) {
  //do stuff with the pasted image
  //console.log(base64)

  $.ajax({
    url: &#39;http://localhost:2929/api/upload-img&#39;,
    dataType: &#39;JSON&#39;,
    data: {
      imgData: base64},
    type: &#39;POST&#39;,
    success: function(data) {
      console.log(data);
    }
  });

};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;服务器端代码&lt;/h3&gt;

&lt;p&gt;服务器端获取到base64数据，即可将base64数据转为图片存储或者传送到其他服务器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export default function uploadImg(req, res) {

  new Promise((resolve, reject) =&amp;gt; {

    var fs = require(&#39;fs&#39;);
    var base64Data = req.body.imgData.replace(/^data:image\/png;base64,/, &quot;&quot;);

    fs.writeFile(&quot;out.png&quot;, base64Data, &#39;base64&#39;, function(err) {
      console.log(err);
    });  

  });

}
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>关于生活方式</title>
     <link href="http://korbinzhao.github.io/about-life-style"/>
     <updated>2015-11-23T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/about-life-style</id>
     <content type="html">&lt;p&gt;最近对生活方式有点感悟，正式因为意识到自己正拥有着一种槽糕的生活方式，并萌生了要改变的想法。&lt;/p&gt;

&lt;h2&gt;关于过去&lt;/h2&gt;

&lt;p&gt;平时工作累了，回到家往床上一躺，打开电脑这里点点那里点点，也不知道自己到底在干什么，时间飞快的过去。美其名曰是放空自己，实际上是一种彻头彻尾的逃避和浪费时间，想想这种方式只会让自己很消沉、沉浸在自己的情绪里难以自拔。浪费完时间，发现本来可以做的事情一件都没做，于是自己又陷入一种紧张感，让自己永远生活在一种紧迫之中。&lt;/p&gt;

&lt;p&gt;这种状态从研三到现在已经持续了相当长一段时间了。或许是自己的内心太不强大，或许是太不会一个人生活。无论是什么原因，其实都迫切需要解决，不能期待他人拯救，只能自我救赎。&lt;/p&gt;

&lt;p&gt;我习惯的状态是怎样的呢？彻彻底底的放空自己，什么都不想，什么都不面对。如果可以一直这样倒还挺好。但是现实是我们都不得不回到现实，照照镜子要面对自己，在公司要面对工作中的琐事。。一颗懒散疲惫的心得不到正确的放松和休息，只会让自己陷入恶性循环。&lt;/p&gt;

&lt;p&gt;这就是我经历着的过去。&lt;/p&gt;

&lt;h2&gt;关于快乐&lt;/h2&gt;

&lt;p&gt;其实大多数人都知道生活的本质就是快乐。但是正如《后会无期》里的一句台词：“听过很多道理，依然过不好这一生。” 我很想时时刻刻快乐，但是事实好像并不如人意。&lt;/p&gt;

&lt;p&gt;回想过去快乐的时光，全部都是和朋友们一起的时光。我怀念2011年的夏天，在中山实习的短短1个月，让我彻底忘却所有烦恼，心中没有一丁点的负担，不会为过去做的窘事懊恼，不会对未来担忧。每一分每一秒都是纯粹的开心。快乐到已经忘却整个世界，或者是觉得当时的生活就是整个世界。这或许就是朋友和陪伴的力量，那种轻松和自在是我自从初中开始就从未拥有过的。十年寒窗的坚持让我习惯了用一种苦涩去面对现实和未来，我仿佛失去了快乐的能力。感谢那个夏天让我重拾了快乐的能力，感谢那时陪在我身边的人。我怀念工作后浙西大峡谷的自驾行，虽然只发生在不久前，虽然作为一个闪亮的灯泡照耀在两对情侣身边，但是很感谢有两位即使有女朋友依旧没有忘记我的朋友，我感受到被朋友重视的感觉，我很珍惜和你们在一起的每分每秒。我怀念PD邀请一群工作伙伴一起吃的一顿饭，让我感受到你们生活的精致和追求，让我感受到和不同岗位一伙伴一起交流的乐趣。。这个世界很大，有趣的人太多，不落单的时光才是快乐的时光。&lt;/p&gt;

&lt;p&gt;当我独立面对自己，总会陷入一种难以自拔的窘境。所以我说，我太不会一个人生活。我只会用懒散的状态去放空自己，计划中的事情总是拖到不能再拖的时候才会去做，最后白白浪费大量空闲时间。等到突然意识到一大堆事情没做的时候，又会更加加剧自己的焦躁心理，从而陷入一种恶性循环。这是一个可怕的循环，我现在正在反复经历着。每当独处的时候都会很不快乐，以上分析就是现在这种糟糕状态的根本原因。&lt;/p&gt;

&lt;p&gt;只有跳出这个循环，只有充分利用这些空闲时间，你才能活出自己的生活，积累出超出别人的工作成绩。如果这种状态不改变，只能一直平凡、平庸下去。&lt;/p&gt;

&lt;h2&gt;关于生活方式&lt;/h2&gt;

&lt;p&gt;上一节里分析了我为什么独处的时候那么不快乐。那么到底要怎样摆脱这种恶性循环呢。我能想到的答案就是生活方式的一种改变，或者说是一种习惯的养成。&lt;/p&gt;

&lt;h3&gt;晚上回家后，不管多累先洗澡&lt;/h3&gt;

&lt;p&gt;现在的现状是每天一回家，累得浑身好像一点力气都没有，浑身的疲累和一脸的油全然不顾，就往床上一躺，打开电脑开始漫无目的的上网、看视频，最后时间飞快的到了12点多，然后洗个澡，然后又变精神了，最后折腾折腾，不到1点半肯定是没法安心入睡的，第二天一觉睡到九点多挣扎着起来，上班的时候也没啥精神。这是一个很坏的习惯，浪费了时间，养成了坏的作息习惯，也不利于身体健康。&lt;/p&gt;

&lt;p&gt;所以回到家后，先洗澡，让自己从疲劳的状态中暂时精神起来，然后就可以把今天的工作整理整理，文章写一写，运动做一下。最后累了，躺在床上安然入睡。&lt;/p&gt;

&lt;h3&gt;床只能是睡觉的地方。躺在床上玩电脑，玩手机，赖床这种行为绝对禁止。&lt;/h3&gt;

&lt;p&gt;为什么每天很晚才能睡着，很重要的一个原因是回到家后，基本大部分行为都是在床上完成的，比如看视频，玩手机游戏。玩手机、看视频本身就是让人精神亢奋的事情，当然很难入睡，长期养成条件反射行为，人一到床上就兴奋的没有睡意，而不是一沾枕头就着。&lt;/p&gt;

&lt;h3&gt;椅子靠背不许用。&lt;/h3&gt;

&lt;p&gt;之前的一个很大的坏习惯是每次坐在椅子上其实都只能用“瘫坐”这个词来形容。仿佛没有脊椎一样，一定要靠在椅背上才算舒服。但是长时间靠椅背会让人很快进入疲劳状态还不自觉，瘫坐在椅子上很长时间，虽然很累，却也懒得起来活动一下。长时间的瘫坐在椅子上，还会形成弯腰驼背，容易得脊椎病。直挺挺的坐在椅子上恰恰相反，脊椎会利用自身的自然弯曲分散上身重量，久坐也不易感觉疲累，更不会弯腰驼背，累了也会很自然的站起来活动，不会有倦怠心理，连站起来活动都懒得做（这种行为和赖床也有点像，躺在床上越累越不愿起来）。&lt;/p&gt;

&lt;h2&gt;关于行动&lt;/h2&gt;

&lt;p&gt;其实不大好意思说“行动”这个词，因为每次给自己定一个计划，大多数情况最后都不了了之了。但是这次，我想说：“我是认真的，因为我意识到了问题的严重性。”&lt;/p&gt;

&lt;p&gt;后面我会每周过来更新下状态，记录下执行情况。虽然我知道这篇文章也不会有几个人看到。毕竟是自己写给自己的。&lt;/p&gt;

&lt;p&gt;----------- 2015-11-23 -----------&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>和PD、运营、设计师和用研们的一顿饭</title>
     <link href="http://korbinzhao.github.io/a-meal-with-colleagues"/>
     <updated>2015-11-16T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/a-meal-with-colleagues</id>
     <content type="html">&lt;p&gt;受PD的邀请，今晚一帮同事去她家做客。去之前，其实心里很是忐忑，自己面对一帮陌生人总会多多少少有些逃避的心理。但是理智告诉我，还是必须得去的，虽然平时工作很忙，经常陷入某个难缠的bug好久，让自己越发的有些寡言少语。一来这不是我想要的状态，二来长此以往是非常不健康的。&lt;/p&gt;

&lt;h2&gt;经过&lt;/h2&gt;

&lt;p&gt;去之前买了点水果带过去，否则空着手去做客太说不过去了。幸好买了，其实大家过去也都多多少少带了些东西，比如水果、红酒。PD家离我住的地方倒也非常近，打了车5分钟就到小区门口了，从小区门口进去一直走，穿过漆黑一片的小路，最近好不容易找到PD的家。&lt;/p&gt;

&lt;p&gt;小区配套挺差的，连个路灯都没开，附近可以吃饭消遣的地方看起来也不多。但是，已进入房间，顿时眼前一亮，装修不同，真的可以给同样的房子带来完全不同的感觉。超大的客厅（把原来的客厅和一个卧室打通连在一起），客厅中间放着沙发、对面是超大的电视屏幕，后面是一张很大的工作长桌，客人多的时候可以用来当做餐桌（当然，这次就是这样做的），房间内到处都是简约却充满文艺气息的装饰品，房子位于顶楼，复式结构，二楼虽然只是楼顶屋檐下面的一点空间，但是布局合理，丝毫没有压抑的感觉，而且还有2个天窗，天气好的时候抬头就可以看到星星。一句话总结，这房子完全像是设计师精心设计过的房子，但是事实上只是房子的主人——另一个PD的设计，果然是一个充满设计师气质的PD。&lt;/p&gt;

&lt;p&gt;晚饭完全有一个帅帅的运营下厨，扬州人，之前还合作过，其实想说我和扬州还有些渊源，后来忍住没说。最后7点半，前前后后到了有十来个人。晚餐超级丰盛，三文鱼、酸菜鱼、蒜蓉油虾、香橙鸡肉沙拉、啤酒红烧肉、红焖茄子、蒜炒白菜、毛豆米、拍黄瓜、焗海蟹、烤鸡翅、各种糕点。。。我只想说城里人真会吃。还没开始吃饭，下厨的运营就开了一瓶红酒，其他人根据自己喜好选择红酒、果汁。席间还尝试了“peng”一下的喝法，就是用一种叫不出名字的国外的白酒兑上雪碧，手掌按住杯口，往桌子上猛地一按，“peng”的一下，然后往酒里撒点盐，一饮而尽。第一次尝试这种喝法，还挺爽的。&lt;/p&gt;

&lt;h2&gt;感想&lt;/h2&gt;

&lt;p&gt;其实呢，之所有有冲动把简单的一顿饭写出来，就是想谈谈感受。在技术团队待久了，每天对着电脑敲代码，需要说话的场景不是很多，再加上技术团队整体在性格上会比较沉闷，在生活品质和乐趣上的追求也没有其他团队那么多。让我这段时间总感觉有些无聊，心情莫名低落，即使好不容易有点时间也宁愿宅着，有一种非常懒散拖延的状态。这种状态于工作、于生活都不是太好的。所以这里提醒下自己，多走出去，多和不同背景、不同岗位的人交流，这不仅有利于拓宽自己的视野，也会让自己更开心一点。正如今天的这次简单的聚会，虽然去之前略感忐忑，去之后却感觉很享受这个过程，每个人仿佛都有着自己独特的故事、自己独特的生活乐趣，这也是我想经历和正在追求的。&lt;/p&gt;

&lt;p&gt;另外，和有趣的人一起，你也会变得有趣。现在的我有点太无聊了，自己都受不了自己。我需要和有趣的人在一起。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Date对象的浏览器兼容性问题</title>
     <link href="http://korbinzhao.github.io/date-cross-browser-safari-chrome"/>
     <updated>2015-11-06T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/date-cross-browser-safari-chrome</id>
     <content type="html">&lt;h2&gt;new Date()、Date.parse()方法在浏览器中的兼容性问题&lt;/h2&gt;

&lt;p&gt;   Date在不同浏览器中对于传入的时间字符串的格式要求是不一样的。比如在chrome浏览器的控制台中输入以下内容，会得到相应结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Date.parse(&#39;2015-11-11 00:00:00&#39;)
//-&amp;gt;1447171200000
Date.parse(&#39;2015/11/11 00:00:00&#39;)
//-&amp;gt;1447171200000
new Date(&#39;2015-11-11 00:00:00&#39;)
//-&amp;gt;Wed Nov 11 2015 00:00:00 GMT+0800 (CST)
new Date(&#39;2015/11/11 00:00:00&#39;)
//-&amp;gt;Wed Nov 11 2015 00:00:00 GMT+0800 (CST)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  可以发现，chrome对于&#39;-&#39;和&#39;/&#39;分割日期的形式都是支持的，能够返回正确的毫秒数或者时间格式。&lt;/p&gt;

&lt;p&gt;  下面在safari浏览器中输入相同内容，查看对应结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Date.parse(&#39;2015-11-11 00:00:00&#39;)
&amp;lt; NaN = $1
&amp;gt; Date.parse(&#39;2015/11/11 00:00:00&#39;)
&amp;lt; 1447171200000 = $2
&amp;gt; new Date(&#39;2015-11-11 00:00:00&#39;)
&amp;lt; Invalid Date = $3
&amp;gt; new Date(&#39;2015/11/11 00:00:00&#39;)
&amp;lt; Wed Nov 11 2015 00:00:00 GMT+0800 (CST) = $4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   可以发现，safari仅对&#39;/&#39;分割日期的形式支持，对&#39;-&#39;分割日期的形式并不支持。&lt;/p&gt;

&lt;p&gt;  通过以上实验，我们可以观察出chrome和safari对于不同格式的时间字符串的支持情况。chrome同时支持&#39;-&#39;和&#39;/&#39;分割日期的时间字符串；safari不支持&#39;-&#39;分割日期的时间字符串。&lt;/p&gt;

&lt;h2&gt;一个简单有效的解决方法&lt;/h2&gt;

&lt;p&gt;  下面是一个比较好的解决方案：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var arr = &quot;2010-03-15 10:30:00&quot;.split(/[- / :]/),
    date = new Date(arr[0], arr[1]-1, arr[2], arr[3], arr[4], arr[5]);

  console.log(date);
  //-&amp;gt; Mon Mar 15 2010 10:30:00 GMT+0000 (GMT Standard Time)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;   该方法为先将时间字符串用split方法进行分割拼装为一个数组，再将每个数组的项作为传参传入new Date()方法，从而将不同形式的字符串转换成有效的时间。
   该方法对于所有浏览器生效。&lt;/p&gt;

&lt;h2&gt;参考资料：&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/5324178/javascript-date-parsing-on-iphone&quot;&gt;http://stackoverflow.com/questions/5324178/javascript-date-parsing-on-iphone&lt;/a&gt;&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>网站分析指标</title>
     <link href="http://korbinzhao.github.io/key-indicator-website-analysis"/>
     <updated>2015-11-01T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/key-indicator-website-analysis</id>
     <content type="html">&lt;h2&gt;1. UV（Unique Vistor）&lt;/h2&gt;

&lt;p&gt;UV是指唯一的访问者。00:00-24:00内相同的UV只被计算一次。&lt;/p&gt;

&lt;h3&gt;网站分析工具如何辨别UV&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;通过服务器
服务器从浏览器接收到的每次请求都会包含IP、请求时间、浏览器版本、操作系统版本等很多信息，服务器可以根据某些共同特征，来判断是否是同一个UV。不过根据IP判断UV并不十分准确，尤其是在公用IP的局域网环境下。&lt;/li&gt;
&lt;li&gt;通过cookie
浏览器第一次访问某个网站服务器时，服务器会给浏览器发送一个cookie，这个cookie会分配给你一个独一无二的编号，并且会记录你访问服务器的信息，例如访问时间、访问的网页、是否登录、登录的账号信息等。当浏览器再一次访问服务器时，服务器获取到cookie，并对里面的信息进行更新，但是给你的编号是不会变的。cookie中拥有相同编号的两个请求会被认定为同一个visitor。这个方法比上一个更精确些，但是在浏览器禁用cookie或者用户经常删除cookie的情况下，这种方式也将失效。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;2. PV（Page View）&lt;/h2&gt;

&lt;p&gt;PV（page view），即页面浏览量，或点击量。一个PV指的是一次从网站下载一个页面的请求（A page view or page impression is a request to load a single page of an Internet site.）。&lt;/p&gt;

&lt;h2&gt;3. Bounce Rate&lt;/h2&gt;

&lt;p&gt;Bounce Rate，指的是在对一个页面的所有访问中，只浏览却没有发生任何点击的访问所占的比率。这种跳失一般发生在用户误点跳转链接或是进入网页后发现内容非常不感兴趣时。&lt;/p&gt;

&lt;p&gt;用一个公式来表示Bounce Rate，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Omniture的计算方法：

Bounce Rate = Single Page Visits / Total Visits
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不过Bounce Rate存在另一种计算方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Google Analytics等工具的计算方法：

Bounce Rate = Single PV Visits / Total Visits 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Page Visits 和 PV Visits的主要区别在于在用户刷新时，对visits的统计是否会+1. 举例说明，用户进入页面后在没有任何操作情况下，刷新一次页面Page Visits不会+1，而PV就会+1，使得PV变为2.&lt;/p&gt;

&lt;p&gt;这两种计算方法的具体区别详见&lt;a href=&quot;http://www.woshipm.com/operate/83233.html&quot;&gt;网站分析的最基本度量&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;4. 跳失率&lt;/h2&gt;

&lt;p&gt;业界有『exit rate』和『bounce rate』两个概念，其中『exit rate』指该网页是会话中『最后一页』的浏览占此网页总浏览量的百分比，而『bounce rate』是指该网页是会话中“唯一网页”的会话占从此网页开始的所有会话的百分比。&lt;/p&gt;

&lt;h2&gt;PS：&lt;/h2&gt;

&lt;p&gt;当然，以上这些概念只是行业通用的一些行业，有些甚至没有统一的界定和标准。每个公司都有自己的一套界定规范。如果你是身在职场的孩子，不妨详细了解下本公司对各网站分析指标的详细界定。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>原生JS实现页面滚动方向检测</title>
     <link href="http://korbinzhao.github.io/js-scroll-direction"/>
     <updated>2015-10-27T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/js-scroll-direction</id>
     <content type="html">&lt;p&gt;判断页面滚动方向是一个常见的需求，下面展示一个使用原生JS方式判断页面滚动方向的解决方式。&lt;/p&gt;

&lt;h2&gt;html&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&quot;http://g.tbcdn.cn/tb/kimi/0.0.233/kimi.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;body style=&quot;height: 6000px;&quot;&amp;gt;
    &amp;lt;div class=&quot;nav&quot; style=&quot;position:fixed; top:0;left:0;width: 100%;height: 60px;background-color: pink;&quot;&amp;gt;&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;js&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;  var $nav = $(&#39;.nav&#39;);
  var $result = $(&#39;.result&#39;);

  //页面滚动监听事件
  window.onscroll = function(e){
    $result.html(&#39;swipeDown&#39;);
    scrollFunc();
    if(scrollDirection == &#39;down&#39;){
      $nav.css({
        position: &#39;absolute&#39;
      });
    }
    else if(scrollDirection == &#39;up&#39;){
      $nav.css({
        position: &#39;fixed&#39;
      });
    }
  }
  var scrollAction = {x: &#39;undefined&#39;, y: &#39;undefined&#39;}, scrollDirection;

  //判断页面滚动方向
  function scrollFunc() {
    if (typeof scrollAction.x == &#39;undefined&#39;) {
      scrollAction.x = window.pageXOffset;
      scrollAction.y = window.pageYOffset;
    }
    var diffX = scrollAction.x - window.pageXOffset;
    var diffY = scrollAction.y - window.pageYOffset;
    if (diffX &amp;lt; 0) {
    // Scroll right
      scrollDirection = &#39;right&#39;;
    } else if (diffX &amp;gt; 0) {
    // Scroll left
      scrollDirection = &#39;left&#39;;
    } else if (diffY &amp;lt; 0) {
    // Scroll down
      scrollDirection = &#39;down&#39;;
    } else if (diffY &amp;gt; 0) {
    // Scroll up
      scrollDirection = &#39;up&#39;;
    } else {
    // First scroll event
    }
    scrollAction.x = window.pageXOffset;
    scrollAction.y = window.pageYOffset;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;github地址&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;https://github.com/korbinzhao/exercise/blob/master/js-scroll-direction.html
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
 
</feed>
