<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>Joebon's world</title>
   <link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://localhost:4000" rel="alternate" type="text/html" />
   <updated>2017-11-18T13:21:58+08:00</updated>
   <id>http://localhost:4000</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>无线性能优化</title>
     <link href="http://korbinzhao.github.io/performance-optimization"/>
     <updated>2016-05-11T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/performance-optimization</id>
     <content type="html">&lt;p&gt;无线性能优化可分为“加载性能”、“渲染性能”、“感知性能”。&lt;/p&gt;

&lt;h2&gt;加载性能&lt;/h2&gt;

&lt;p&gt;我们在谈到加载性能时，一般关注的是页面的首屏加载速度。&lt;/p&gt;

&lt;h3&gt;webp&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://developers.google.com/speed/webp/&quot;&gt;WebP&lt;/a&gt;，是一种支持有损压缩和无损压缩的图片文件格式。根据 Google 官方的数据，无损压缩后的 WebP 比 PNG 文件少了 26％ 的文件大小，有损压缩在具有同等SSIM索引的情况下WebP 比 JPEG 文件少25-34%的文件大小。&lt;/p&gt;

&lt;h3&gt;iconfont&lt;/h3&gt;

&lt;p&gt;iconfont 对于前端来说有很多优点，自由变化大小、矢量不失真、自由修改颜色、可以添加一些视觉效果，如阴影、旋转、透明度，兼容 IE6.&lt;/p&gt;

&lt;p&gt;可通过 &lt;a href=&quot;http://www.iconfont.cn/&quot;&gt;iconfont&lt;/a&gt; 平台使用，使用格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @font-face {
        font-family: &quot;iconfont&quot;;
        src: url('iconfont.eot'); /* IE9*/
        src: url('iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
        url('iconfont.woff') format('woff'), /* chrome、firefox */
        url('iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/
        url('iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在移动端，目前只需引用一个 ttf 文件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @font-face {
        font-family: &quot;iconfont&quot;;
        src: url('iconfont.ttf') format('truetype');
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;小于 10K 的 ttf 文件建议 base64 在 css 文件中。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @font-face {
        font-family: &quot;iconfont&quot;;
        src: url('data:application/x-font-ttf;base64,AAEAAAAPAIAAAwBwRkZUTXCKsTYAAAD8AAAAHE9TLzJWulwpAAABGAAAAGBjbWFwzCYhagAAAXgAAAFKY3Z0IAyV/7YAAAmUAAAAJGZwZ20w956VAAAJuAAACZZnYXNwAAAAEAAACYwAAAAIZ2x5Zn46oOwAAALEAAADyGhlYWQHSlJcAAAGjAAAADZoaGVhBzID5wAABsQAAAAkaG10eAq0AM4AAAboAAAAFGxvY2EBjAI0AAAG/AAAAAxtYXhwAScKKwAABwgAAAAgbmFtZQV/3xUAAAcoAAACLnBvc3RMkaPUAAAJWAAAADRwcmVwpbm+ZgAAE1AAAACVAAAAAQAAAADMPaLPAAAAANImhzMAAAAA0iaHMwAEA/QB9AAFAAACmQLMAAAAjwKZAswAAAHrADMBCQAAAgAGAwAAAAAAAAAAAAEQAAAAAAAAAAAAAABQZkVkAMAAeOZFAyz/LABcAxgAHwAAAAEAAAAAAxgAAAAAACAAAQAAAAMAAAADAAAAHAABAAAAAABEAAMAAQAAABwABAAoAAAABgAEAAEAAgB45kX//wAAAHjmRf///4sZvwABAAAAAAAAAAABBgAAAQAAAAAAAAABAgAAAAIAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAIgAAATICqgADAAcAKUAmAAAAAwIAEErLbBDLLIAADorLbBELLIAATorLbBFLLIBADorLbBGLLIBATorLbBHLLIAADsrLbBILLIAATsrLbBJLLIBADsrLbBKLLIBATsrLbBLLLIAADcrLbBMLLIAATcrLbBNLLIBADcrLbBOLLIBATcrLbBPLLIAADkrLbBQLLIAATkrLbBRLLIBADkrLbBSLLIBATkrLbBTLLIAADwrLbBULLIAATwrLbBVLLIBADwrLbBWLLIBATwrLbBXLLIAADgrLbBYLLIAATgrLbBZLLIBADgrLbBaLLIBATgrLbBbLLAwKy6xJAEUKy2wXCywMCuwNCstsF0ssDArsDUrLbBeLLAAFrAwK7A2Ky2wXyywMSsusSQBFCstsGAssDErsDQrLbBhLLAxK7A1Ky2wYiywMSuwNistsGMssDIrLrEkARQrLbBkLLAyK7A0Ky2wZSywMiuwNSstsGYssDIrsDYrLbBnLLAzKy6xJAEUKy2waCywMyuwNCstsGkssDMrsDUrLbBqLLAzK7A2Ky2waywrsAhlsAMkUHiwARUwLQAAS7gAyFJYsQEBjlm5CAAIAGMgsAEjRCCwAyNwsA5FICBLuAAOUUuwBlNaWLA0G7AoWWBmIIpVWLACJWGwAUVjI2KwAiNEswoJBQQrswoLBQQrsw4PBQQrWbIEKAlFUkSzCg0GBCuxBgFEsSQBiFFYsECIWLEGA0SxJgGIUVi4BACIWLEGAURZWVlZuAH/hbAEjbEFAEQAAAA=') format('truetype');
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;sprite 图片&lt;/h3&gt;

&lt;p&gt;Sprite 图片（又称：雪碧图）被运用在众多使用了很多小图标的网站上。sprite 图将众多小图标集成到一张图片上。通过减少请求数提升了性能。在移动端，使用雪碧图时也要注意图片尺寸不能过大，因为图片越大，解码内存消耗就越大，如果过大反而会影响性能。&lt;/p&gt;

&lt;p&gt;解码内存消耗（decoded in memory)的计算公式： （w x h x 4）宽 x 高 x 每个像素4个字节数&lt;/p&gt;

&lt;p&gt;如果设备 DPI 大于1，还需要乘以 DPI 系数，如 Retina 设备 乘以 4 ，RetinaHD 设备乘以 9.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://gtms02.alicdn.com/tps/i2/TB11_q7HVXXXXbTXVXXWwRTPpXX-1577-730.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;考虑到解码内存消耗，合理的生成紧凑的 Sprite 图，既可以带来更少的请求数，又可以保证尽量低的消耗。&lt;/p&gt;

&lt;h3&gt;按需加载&lt;/h3&gt;

&lt;h2&gt;渲染性能&lt;/h2&gt;

&lt;h3&gt;设备刷新率&lt;/h3&gt;

&lt;p&gt;设备刷新率是影响我们对于页面滚动、动画流畅性感知的重要参数。&lt;/p&gt;

&lt;p&gt;页面运行在设备的浏览器中，现在市面上的移动设备的刷新频率大多是 60次/秒。所以给浏览器渲染每一帧画面的时间应该是（1s/60=16.67ms）。&lt;/p&gt;

&lt;p&gt;实际上，浏览器并不是把所有时间都花在页面渲染上，还需要做诸如渲染队列管理、不同线程切换等额外工作。所以单纯的浏览器渲染工作留给我们的时间也就是10ms左右。当每一帧渲染操作的时间大于这个时间时，页面就会表现的比较卡顿。&lt;/p&gt;

&lt;h3&gt;浏览器的页面渲染流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;HTML。根据服务器端的 HTML 代码，形成文档对象模型（DOM）&lt;/li&gt;
&lt;li&gt;Style。 加载并解析样式，形成 CSS 对象模型&lt;/li&gt;
&lt;li&gt;Layout。在文档对象模型和 CSS 对象模型基础上，生成一颗由一组待生成渲染的对象组成的渲染树;对渲染树上的每个元素，计算其坐标，称之为布局&lt;/li&gt;
&lt;li&gt;Paint。渲染树上的元素最终展现在浏览器上，称之为“painting”。一般来说，这个绘制过程是在多个层上完成&lt;/li&gt;
&lt;li&gt;Composite。由上一步可知，对页面中 DOM 元素的绘制时在多个层上进行的。在每个蹭上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;如何排查渲染性能问题&lt;/h3&gt;

&lt;p&gt;首先使用 chrome 的 Timeline ，滚动页面，进行 record 。得到如下结果，其中绿色的波浪线就是页面的帧率。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1JXsbLFXXXXafaXXXXXXXXXXX-712-74.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中波浪线越高表示帧率越高，同时，帧率区域上边标红的一行，表示有问题的帧。&lt;/p&gt;

&lt;p&gt;逐一排查标红的帧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1c2cXLFXXXXbaaXXXXXXXXXXX-531-247.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后，点击选中该帧，可以看到详细的耗时和简单的问题描述。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1jZH6LFXXXXakapXXXXXXXXXX-572-256.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本例中，该帧耗时过长，会导致卡顿。&lt;/p&gt;

&lt;h4&gt;JS 分析&lt;/h4&gt;

&lt;p&gt;发现了运行时间很长的 JS 代码，那么你可以开启 DevTools 中顶部的 JS Profiler 选项：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1UtwrLFXXXXcXXpXXXXXXXXXX-307-88.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;开启后，会看到更多细节：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1Tp.pLFXXXXcOXpXXXXXXXXXX-766-462.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中，浅绿色的为函数调用的链路，更详细的，可以切换至 Call Tree 的 Tab 页：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1fyMbLFXXXXX9aXXXXXXXXXXX-760-283.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;render 分析&lt;/h4&gt;

&lt;p&gt;render 部分包括 Recalculate Style 和 Layout ，如果发现 render 部分耗时过长，需要分别从这两部分进行分析。&lt;/p&gt;

&lt;p&gt;如果某一帧触发了强制 layout ， Timeline 会用红色角标标出:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1lEEELFXXXXXbXXXXXXXXXXXX-507-174.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如何需要具体分析 Recalculate Style ， 可以选中 Recalculate Style 部分，下面详细列出了受影响的元素个数、触发 Recalculate Style 函数一级警告提示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1NCIsLFXXXXbjXpXXXXXXXXXX-853-216.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;更加直观的函数调用，可以切换至 Bottom-Up 的 Tab 页，来查看逆向的调用，方便定位触发的函数位置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1KBEALFXXXXbsXXXXXXXXXXXX-812-169.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果需要分析 Layout ，可以选中 Layout 部分，同 Recalculate Style 一样。&lt;/p&gt;

&lt;h4&gt;paint 分析&lt;/h4&gt;

&lt;p&gt;你可以选中 Timeline 中绿色的 paint 部分：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1hUMnLFXXXXagXFXXXXXXXXXX-573-574.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;summary 会展示绘制的总体情况，包括绘制的元素、元素本身绘制耗时、元素子元素绘制耗时。&lt;/p&gt;

&lt;p&gt;更加详细的信息，可以切换至 Paint Profiler ，包括了每个具体 Paint 的调用和 Paint 区域截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB15bUeLFXXXXbEXVXXXXXXXXXX-736-348.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;composite 分析&lt;/h4&gt;

&lt;p&gt;分析 composite （合成）时，需要选中一帧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1sar9LFXXXXcWaXXXXXXXXXXX-680-119.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击这个 Layers 选项卡，你会看到一个新的视图。在这个视图中，你可以对这一帧中的所有渲染层进行扫描、缩放等操作，同时还能看到每个渲染层被创建的原因：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/tps/TB1yV7uLFXXXXaMXpXXXXXXXXXX-979-356.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有了这个视图，你就能知道页面中到底有多少个渲染层。如果你在对页面滚动或者渐变效果的性能分析中发现渲染层的合并过程耗费了太多时间（相对于4-5毫秒的预期），那么久可以从这个视图中看到页面中有多少个渲染层，何时被创建，从而对渲染层的数量进行优化。&lt;/p&gt;

&lt;h3&gt;Script - 优化JS的执行效率&lt;/h3&gt;

&lt;p&gt;错误的执行时机和太长的时间消耗是常见的导致 JS 性能低下的原因。&lt;/p&gt;

&lt;h4&gt;概要&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;对于动画效果的实现，避免使用 setTimeout 或 setInterval ，请使用 requestAnimationFrame。&lt;/li&gt;
&lt;li&gt;把耗时的 JS 代码放到 Web Workers 中去做。&lt;/li&gt;
&lt;li&gt;把 DOM 元素的更新划分为多个小任务，分别在多个 frame 中去完成。&lt;/li&gt;
&lt;li&gt;使用 Chrome DevTools 的 Timeline 和 JS Profiler 来分析 JS 的性能。&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;使用 requestAnimationFrame&lt;/h4&gt;

&lt;p&gt;window.requestAnimationFrame 是一个专门为动画而生的 web API 。它通过浏览器在页面重回前执行你的回调函数。通常来说被调用的频率是每秒60次。&lt;/p&gt;

&lt;p&gt;很多框架和示例代码都是用 setTimeout 或 setInterval 来实现页面的动画效果，比如 jQuery 中的 animation。这种实现方式的问题是，你在 setTimeout 或者 setInterval 中指定的回调函数的执行时机是无法保证的。他将在这一帧动画的某个时间点被执行，很可能是在帧结束的时候。这就意味着我们可能失去这一帧的信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://segmentfault.com/img/bVvdhN&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;requestAnimationFrame 的其他高能用法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;动画： 也是它的主要用途，它将我们动画的执行时机和执行频率交由浏览器决定，以得到更好的性能。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数节流：requestAnimationFrame 的执行频率（一帧）是16.67ms，利用这一特性就可以做到函数节流，避免高频事件在一帧内做多与的无用功的函数执行，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var $box = $('#J_Test'),
  $point = $box.find('b');
  $box.on('mouseenter',function(e){
  requestAnimationFrame(function(){
          $point.css({
              top : e.pageY,
          left : e.pageX
          })
      });
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分帧初始化：同样利用一帧的执行时间将模块的初始化或渲染函数分散到不同的帧中来执行，这样每个模块都有16.67ms的执行时间，而不是一股脑的堆在哪里等着执行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      var rAF = window.requestAnimationFrame ||  window.webkitRequestAnimationFrame ||
      function(c) {
          setTimeout(c, 1 / 60 * 1000);
      };

      function render() {
      self.$container.html(itemHtml);
      self.$container.find('.J_LazyLoad').lazyload();
      }

      rAF(render);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h4&gt;使用 transform 实现动画 （待定）&lt;/h4&gt;

&lt;p&gt;css transition 是我们在实现一个动画是能够想到的最简单的一种实现方式。但是当频繁操作样式时，也会出现动画不怎么流畅的问题。&lt;/p&gt;

&lt;p&gt;解决这一问题的一个方式就是使用 transform 来实现相同的效果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;transition: left 2s ease-in-out;  ---&amp;gt; transition: transform 2s ease-in-out;
left: xxx; ---&amp;gt; transform: translate3d(xxx, yyy, zzz);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;硬件（GPU）加速&lt;/h4&gt;

&lt;p&gt;硬件（GPU）加速，即层的合成（layer composite）。我们常说的使用 translate3D 开启硬件加速，其实是使应用了 translate3D 的元素获得独立的 GraphicsLayer，好处如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个 GraphicsLayer 都有一个 GraphicsContext， GraphicsContext 会输出该层的位图，交由 GPU 合成，比 CPU 要快&lt;/li&gt;
&lt;li&gt;当需要 repaint 时，只要 repaint 自己，不会影响到其他的 GraphicsLayer 。 repaint 完后，只需要通过 GPU 同其它层合并下（composite layers）&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以，在我们平常做动态效果时，会使用 translate3D 的 hack ，利用 GPU 的合成来获取更好的效果和性能。&lt;/p&gt;

&lt;p&gt;传统方式下，浏览器依赖于 CPU 来渲染页面内容。而随着 GPU 硬件能力的不断发展，开始试图使用 GPU 的硬件能力来获得更好的性能和更少的电量消耗。使用 GPU 来渲染合成页面内容可以获得明显的速度提升。&lt;/p&gt;

&lt;h5&gt;合成器&lt;/h5&gt;

&lt;p&gt;chrome 合成器（Compositor）是一个软件库，用来管理 GraphicsLayer 树。&lt;/p&gt;

&lt;h5&gt;GPU&lt;/h5&gt;

&lt;p&gt;合成器会使用 GPU 来执行它的合成绘制步骤。在硬件加速体系结构中，合成由 GPU 负责。合成器本质上也是使用 GPU 将层绘制成一个位图，最后输出到屏幕上。&lt;/p&gt;

&lt;h4&gt;降低代码复杂度或者使用 Web Workers&lt;/h4&gt;

&lt;p&gt;JS 代码是运行在浏览器的主线程上的。与此同时，浏览器的主线程还负责样式计算、布局，甚至绘制的工作。如果 JS 代码运行时间过长，就会阻塞主线程上其他的渲染工作，很可能就会导致帧丢失。&lt;/p&gt;

&lt;p&gt;大多数情况下，可以把纯计算工作放在 Web Workers 中（如果这些计算工作不会涉及 DOM 操作）。一般来说， JS 中数据的处理工作，比如排序或搜索，一般都适合这种处理方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var dataSortWorker = new Worker(&quot;sort-worker.js&quot;);
dataSortWorker.postMesssage(dataToSort);

// The main thread is now free to continue working on other things...

dataSortWorker.addEventListener('message', function(evt) {
var sortedData = e.data;
// Update data on screen...
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 JS 代码需要存取 DOM 元素，也就是说必须在主线程上运行，可以考虑批处理的方式：把任务细分为若干个小任务，每个小任务耗时很少，各自放在一个 requestAminationFrame 中回调运行。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);
requestAnimationFrame(processTaskList);

function processTaskList(taskStartTime) {
    var taskFinishTime;

    do {
    // Assume the next task is pushed onto a stack.
    var nextTask = taskList.pop();

    // Process nextTask.
    processTask(nextTask);

    // Go again if there’s enough time to do the next task.
     taskFinishTime = window.performance.now();
    } while (taskFinishTime - taskStartTime &amp;lt; 3);

    if (taskList.length &amp;gt; 0)
    requestAnimationFrame(processTaskList);

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果采用划分小任务的方式，那么需要确保给用户一个好的 UX/UI，使得用户能够感知到当前浏览器正在处理一个任务，比如一个进度条或者指示器。&lt;/p&gt;

&lt;h4&gt;避免对 JS 代码进行微优化&lt;/h4&gt;

&lt;p&gt;对于一个任务，如果换一种实现方式，浏览器的执行速度可以快100倍，这是非常酷的。比如读取一个元素的 offsetTop 属性就比计算它的 getBoundingClientRect() 要快。但一般情况下，在微优化上花再大的精力，整体上 JS 代码的性能也就获得若干毫秒的提升。这是不划算的。&lt;/p&gt;

&lt;p&gt;简而言之：慎用微优化。因为一般来说，它对你的 web 应用效果不大。&lt;/p&gt;

&lt;h3&gt;Style - 降低样式计算和复杂度&lt;/h3&gt;

&lt;h3&gt;Layout - 避免大规模、复杂布局&lt;/h3&gt;

&lt;p&gt;尽可能避免触发布局&lt;/p&gt;

&lt;h3&gt;Paint&lt;/h3&gt;

&lt;p&gt;如果触发了 Layout，那么一定会触发 Paint。这个很好理解，修改了元素的几何属性意味着元素要重新渲染，除此之外，改变元素的一些非几何属性，比如：背景、颜色、阴影等，不会触发 Layout，但是依然会触发 Paint。&lt;/p&gt;

&lt;h3&gt;composite&lt;/h3&gt;

&lt;p&gt;提升为合成层简单说来有以下几点好处：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;合成层的位图，会交由 GPU 合成，比 CPU 处理要快&lt;/li&gt;
&lt;li&gt;当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层&lt;/li&gt;
&lt;li&gt;对于 transform 和 opacity 效果，不会触发 layout 和 paint&lt;/li&gt;
&lt;li&gt;对于诸如 fixed 的合成层，移动时不会触发 repaint&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;利用合成层对于提升页面性能方面有很大的作用，因此我们也总结了一下几点优化建议。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;提升动画效果的元素&lt;/li&gt;
&lt;li&gt;使用 transform 或者 opacity 来实现动画效果&lt;/li&gt;
&lt;li&gt;减少绘制区域&lt;/li&gt;
&lt;li&gt;&lt;p&gt;合理管理合成层&lt;/p&gt;

&lt;p&gt;  看完上面的文章，你会发现提升合成层会达到更好的性能。这看上去非常诱人，但是问题是，创建一个新的合成层并不是免费的，它得消耗额外的内存和管理资源。实际上，在内存资源有限的设备上，合成层带来的性能改善，肯能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;防止层爆炸&lt;/p&gt;

&lt;p&gt;  通过之前的介绍，我们知道同合成层重叠也会使元素提升为合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况。也就是说除了我们显式的声明的合成层，还可能由于重叠原因不经意间产生一些不在预期的合成层，极端一点可能会产生大量的额外合成层，出现层爆炸的现象。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000005017600&quot;&gt;无线页面动画优化实例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/speed/webp/&quot;&gt;WebP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.iconfont.cn/&quot;&gt;iconfont&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.chrome.com/devtools/docs/timeline&quot;&gt;chrome devtool timeline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/rendering/?hl=zh-cn&quot;&gt;google render performance&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>将 NCR 字符转换为真实字符的方法</title>
     <link href="http://korbinzhao.github.io/convert-numeric-chracter-reference-to-actual-character"/>
     <updated>2016-05-11T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/convert-numeric-chracter-reference-to-actual-character</id>
     <content type="html">&lt;p&gt;开发过程中遇到一种奇怪的编码格式:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;#27599;&amp;amp;#26085;&amp;amp;#19968;&amp;amp;#33394;|&amp;amp;#34013;&amp;amp;#30333;~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用decode/unescape/decodeURI解码均无效.研究一番,总结一下.&lt;/p&gt;

&lt;p&gt;实际上上面这种奇怪的编码格式并不是编码,而是一种叫做 NCR(Numeric Character Reference) 的标记结构.&lt;/p&gt;

&lt;h2&gt;Numeric Character Reference&lt;/h2&gt;

&lt;p&gt;看看维基百科的解释：&lt;/p&gt;

&lt;p&gt;A numeric character reference (NCR) is a common markup construct used in SGML and other SGML-related markup languages such as HTML and XML. It consists of a short sequence of characters that, in turn, represent a single character from the Universal Charact&lt;/p&gt;

&lt;p&gt;NCR是一种常见的标记结构，用于SGML和其他SGML相似的标记语言，如HTML和XML。它由一个短的字符序列组成,代表一个字符（全球的文字字符）。&lt;/p&gt;

&lt;p&gt;NCR编码是由一个与号(&amp;amp;)跟着一个井号(#), 然后跟着这个字符的Unicode编码值, 最后跟着一个分号组成的, 如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;#dddd;
&amp;amp;#xhhhh;
&amp;amp;#name;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中, dddd是字符编码的十进制表示, 而hhhh是字符的16进制表示.&lt;/p&gt;

&lt;p&gt;以 HTML 为例，这三种转义序列都称作 character reference：
前两种是 numeric character reference（NCR），数字取值为目标字符的 Unicode code point；以「&amp;amp;#」开头的后接十进制数字，以「&amp;amp;#x」开头的后接十六进制数字。
后一种是 character entity reference，后接预先定义的 entity 名称，而 entity 声明了自身指代的字符。
从 HTML 4 开始，NCR 以 Unicode 为准，与文档编码无关。&lt;/p&gt;

&lt;p&gt;「中国」二字分别是 Unicode 字符 U+4E2D 和 U+56FD，十六进制表示的 code point 数值「4E2D」和「56FD」就是十进制的「20013」和「22269」。所以——&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;amp;#x4e2d;&amp;amp;#x56fd;
&amp;amp;#20013;&amp;amp;#22269;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;——这两种 NCR 写法都会在显示时转换为「中国」二字。&lt;/p&gt;

&lt;h2&gt;如何将 NCR 字符转换成真实字符&lt;/h2&gt;

&lt;p&gt;方法如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var regex_num_set = /&amp;amp;#(\d+);/g;
var str = &quot;Here is some text: &amp;amp;#27599;&amp;amp;#26085;&amp;amp;#19968;&amp;amp;#33394;|&amp;amp;#34013;&amp;amp;#30333;~&quot;


str = str.replace(regex_num_set, function(_, $1) {
  return String.fromCharCode($1);
});


document.write('&amp;lt;pre&amp;gt;'+JSON.stringify(str,0,3));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上例子使用了 [String.prototype.replace()] 和 String.fromCharCode() 方法. 思路为将字符串中的 NCR 字符逐个获取到 &quot;&amp;amp;#&quot;和&quot;;&quot;间的 Unicode 字符编码值, 然后利用 String.fromCharCode() 方法, 将 Unicode 编码转为真实字符.&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/21390312&quot;&gt;&amp;amp;#x开头的是什么编码呢。浏览器可以解释它。如&amp;#20013;&amp;#22269;等同与中文&quot;中国&quot;?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/35501026/converting-numeric-character-reference-to-actual-character/35501590#35501590&quot;&gt;Converting numeric character reference to actual character&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace&quot;&gt;String.prototype.replace()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/shishm/archive/2011/11/24/2261996.html&quot;&gt;[字符编码]Numeric Character Reference和HTML Entities（一）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>当页面渲染时，浏览器发生了什么</title>
     <link href="http://korbinzhao.github.io/page-render"/>
     <updated>2016-05-09T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/page-render</id>
     <content type="html">&lt;h2&gt;当页面渲染时，浏览器发生了什么&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;根据服务器端的 HTML 代码，形成文档对象模型（DOM）&lt;/li&gt;
&lt;li&gt;加载并解析样式，形成 CSS 对象模型&lt;/li&gt;
&lt;li&gt;在文档对象模型和 CSS 对象模型基础上，生成一颗由一组待生成渲染的对象组成的渲染树&lt;/li&gt;
&lt;li&gt;对渲染树上的每个元素，计算其坐标，称之为布局&lt;/li&gt;
&lt;li&gt;最后，渲染树上的元素最终展现在浏览器上，称之为“painting”&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;渲染基础&lt;/h2&gt;

&lt;p&gt;首先了解下 Blink 引擎是如何渲染页面的。&lt;/p&gt;

&lt;h3&gt;Nodes 和 DOM 树&lt;/h3&gt;

&lt;p&gt;在 Blink 引擎中，页面内容是存储为由 Node 对象组成的树状结构，也就是 DOM 树。每一个 HTML element 元素都有一个 Node 对象与之对应，DOM 树的根节点永远都是 Document Node。&lt;/p&gt;

&lt;h3&gt;从 Nodes 到 RenderObjects&lt;/h3&gt;

&lt;p&gt;DOM 树中的每个 node 节点都有一个对应的 RenderObject 对象。RenderObject 存储在与 DOM 树相应的树形结构中 —— Render Tree。RenderObject 知道如何在屏幕上 paint node 内容，为实现这一操作，RenderObject 会调用其对应的 GraphicsContext 来执行必要的 draw 操作。其中，GraphicsContext 就是负责将像素写入位图（bitmap）中，这些位图最终展示在屏幕中。&lt;/p&gt;

&lt;p&gt;PS: draw != paint，draw 是将像素绘制到屏幕上，而 paint 是生成元素呈现的像素。&lt;/p&gt;

&lt;h3&gt;从 RenderObjects 到 RenderLayers&lt;/h3&gt;

&lt;p&gt;每一个 RenderObject 都直接或间接（通过其父对象）的同一个 RenderLayer 相关联。&lt;/p&gt;

&lt;p&gt;RenderLayer 的作用就是保证页面元素以正确的顺序合成（composited），这样才能正确的展现元素的重叠以及半透明元素等等。会有一些情形，为一些特殊的 RenderObjects 创建一个新的 RenderLayer。以下是常见的一定会新建 RenderLayer 的 RnederObject：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;页面的根节点对应的RenderObject&lt;/li&gt;
&lt;li&gt;有明确的 CSS 定位属性（relative、absolute 或者 transform）&lt;/li&gt;
&lt;li&gt;是透明的&lt;/li&gt;
&lt;li&gt;有 CSS overflow、CSS alpha（遮罩）或者 CSS reflection&lt;/li&gt;
&lt;li&gt;有 CSS 滤镜（filter）&lt;/li&gt;
&lt;li&gt;canvas 元素对应的 RenderObject&lt;/li&gt;
&lt;li&gt;video 元素对应的 RenderObject&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;其他的 RenderObjects 与其最近的拥有 RenderLayer 的父级 RenderObject，拥有同一个 RenderLayer。&lt;/p&gt;

&lt;h3&gt;从 RenderLayers 到 GraphicsLayers&lt;/h3&gt;

&lt;p&gt;为利用合成器（compositer），满足如下条件的 RenderLayers，会被认为是一个独立的合成层。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有 3D 或者 perspective transform 的 CSS 属性的层&lt;/li&gt;
&lt;li&gt;video 元素的层&lt;/li&gt;
&lt;li&gt;canvas 元素的层&lt;/li&gt;
&lt;li&gt;flash&lt;/li&gt;
&lt;li&gt;对 opacity 和 transform 对应了 CSS 动画的层&lt;/li&gt;
&lt;li&gt;使用了 CSS 滤镜（filters）的层&lt;/li&gt;
&lt;li&gt;有合成层后代的层&lt;/li&gt;
&lt;li&gt;同合成层重叠，且在该合成层上面（z-index）渲染的层&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如果 RenderLayer 是一个合成层，那么它有属于自己的单独的 GraphicsLayer，否则它和它最近的又有 GraphicsLayer 的父 layer 共用一个 GraphicsLayer。&lt;/p&gt;

&lt;p&gt;每一个GraphicsLayer都有一个GraphicsContext，其对应的RenderLayer会paint进GraphicsContext中。合成器（compositor）最终会负责，将由GraphicsContext输出的位图（bitmap）合并成最终屏幕显示的图案。&lt;/p&gt;

&lt;h3&gt;层压缩（Layer Squashing）&lt;/h3&gt;

&lt;p&gt;所有的规则都会有漏洞。正如上面提到的，GraphicsLayers会消耗内存和其他资源（随着GraphicsLayer树的大小增长，会使CPU执行时间越来越长）。当一些RenderLayer同一个成为独立合成层的RenderLayer重叠时，就会产生大量的额外的合成层（上节合成层产生条件的最后一条），十分消耗资源。&lt;/p&gt;

&lt;p&gt;我们把产生合成层的自身因素（比如有3D变换的层）称之为直接因素，将比如：合成层后代，同合成层重叠等条件成为简介因素。为了防止上述所说的“层爆炸”，当很多element覆盖在因直接因素产生的层之上时，浏览器的排版引擎，会将这些element的RenderLayers覆盖在这个直接因素产生的RenderLayer上，同时将他们压缩（squash）成一个“层”。这就防止了由覆盖引起的层爆炸。更多细节请看这里和这里&lt;/p&gt;

&lt;h3&gt;从GraphicsLayers到WebLayers再到CC Layers&lt;/h3&gt;

&lt;p&gt;chrome通过WebLayer和cc layer（chrome compositor layer）实现GraphicsLayers。&lt;/p&gt;

&lt;h3&gt;小结&lt;/h3&gt;

&lt;p&gt;总的来说，为rendering服务的有如下四种树形结构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DOM Tree，基本的模型&lt;/li&gt;
&lt;li&gt;RenderObject Tree，同DOM树的可见节点是一一对应的。RenderObject知道如何去paint其相对应的DOM节点&lt;/li&gt;
&lt;li&gt;RenderLayer Tree，由RenderLayers组成，这些RenderLayer对应于RenderObject树的RenderObject。这种对应关系是一对多的。&lt;/li&gt;
&lt;li&gt;GraphicsLayer Tree，由GraphicsLayers组成，这些GraphicsLayer对应于RenderLayer树的RenderLayer。这种对应关系是一对多的。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;img src=&quot;http://img1.tbcdn.cn/L1/461/1/b611c034f6ea0ad700a1319e52076c64316f21a0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;重绘&lt;/h2&gt;

&lt;p&gt;当改变不会影响元素在网页中位置的样式，如 background-color, border-color, visibility 等，浏览器只会用新的样式将元素重绘一遍。&lt;/p&gt;

&lt;h2&gt;重排&lt;/h2&gt;

&lt;p&gt;当改变影响到文本内容或结构，或者元素位置时，就会发生重排。重排由以下事件触发：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;DOM 操作（元素的添加、删除、修改、改变顺序）&lt;/li&gt;
&lt;li&gt;内容变化，包括表单域内的文本变化&lt;/li&gt;
&lt;li&gt;CSS 属性的计算或改变&lt;/li&gt;
&lt;li&gt;添加删除样式表&lt;/li&gt;
&lt;li&gt;更改“类”的属性&lt;/li&gt;
&lt;li&gt;浏览器窗口的操作（缩放、滚动）&lt;/li&gt;
&lt;li&gt;伪类激活（:hover 等）&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;浏览器的优化渲染&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;浏览器会尽可能的将重绘、重构限制在改变元素的区域内。比如，固定或绝对定位的元素，重绘或重排只会影响元素本身或其子元素，静态定位元素会触发后续所有元素的重流。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当 JS 有连续会造成重绘或重排的几段代码时，浏览器会缓存这些改变，在代码运行完毕后再将这些改变一次性应用。举个栗子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var $body = $('body');
  $body.css('padding', '1px'); // reflow, repaint
  $body.css('color', 'red'); // repaint
  $body.css('margin', '2px'); // reflow, repaint
  // only 1 reflow and repaint will actually happen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  以上代码只会触发一次重绘或重排。
  &lt;strong&gt;值得注意的一点，改变元素的属性会触发强制性重排&lt;/strong&gt;。如果我们在上面的代码中加入一行访问元素属性的代码，就会引起两次重排。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  var $body = $('body');
  $body.css('padding', '1px');
  $body.css('padding'); // reading a property, a forced  reflow
  $body.css('color', 'red');
  $body.css('margin', '2px');
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;性能优化的实际意见&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;尽量减少 DOM 操作。在进行复杂的操作时，最好使用“孤立”的元素（与 DOM 脱离，仅保存在内存中的元素），操作完成后再加入 DOM 中。&lt;/li&gt;
&lt;li&gt;改变元素样式时，被操作的元素处于 DOM 渲染树的位置越深越好。&lt;/li&gt;
&lt;li&gt;尽量只给位置绝对或者固定定位的元素添加动画元素。&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;参考文献&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.html-js.com/article/3000&quot;&gt;有关网页渲染，每个前端开发者都该知道的那点事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome&quot;&gt;GPU Accelerated Compositing in Chrome&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>嗯，植发了</title>
     <link href="http://korbinzhao.github.io/hair-transplant"/>
     <updated>2016-04-28T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/hair-transplant</id>
     <content type="html">&lt;h2&gt;岁月是把杀猪刀&lt;/h2&gt;

&lt;p&gt;26岁就面临头发越来越少、额头越来越的境遇，森森的忧桑。小时候长得精致的我，看着一天天、一年年变丑的自己，领会到岁月是把杀猪刀的道理。&lt;/p&gt;

&lt;p&gt;先谈谈自己的脱发史吧，高中上学那会儿，可能因为压力大的原因，就发现头很油、头发很容易掉的问题，不过年纪轻嘛，也没往这方面想。大一大二头发都还挺正常的，到了大三、大四，突然发现自己头发好像留不长了，发型也变得越来越不好看。研究生阶段，整个问题就越发明显了。从脱发开始明显显现到现在也有5年的时间了。这段时间里，脱发也成为了最困扰自己的一个问题。&lt;/p&gt;

&lt;p&gt;了解植发，是从去年开始的。之前去普通医院、皮肤医院都看过，给出的结论基本都是脂溢性脱发，药物治疗只有米诺地尔和非那雄胺比较有效。不过听说非那雄胺会对性功能产生影响，所以一直没敢用。之前用过大概3个月的米诺地尔，因为不了解的原因，主要用在了前额上，现在想想是完全徒劳无功的，因为前额的毛囊基本已经坏死了。当初如果用在头顶部的话，现在应该也会有点效果了。总之，用了一段时间的米诺地尔，一是太麻烦，二是使用位置不对，没啥效果，后来就没坚持下来。大概一年前，去了一家植发机构，大概了解了植发的原理、技术细节和价格。后来一是因为忙，二是不知道哪家植发机构靠谱，这个事情也就耽搁了下来。&lt;/p&gt;

&lt;h2&gt;决定植发了&lt;/h2&gt;

&lt;p&gt;作为外貌协会会员，对自己的形象还是很在意的。有时照一眼镜子，可能影响一天的心情。这个心结其实让我在了解植发之初，就已经决定要走植发这条路了。不过一直迟迟没有做植发的一个重要原因是不知道如何去选择一家靠谱的植发机构。可能是因为里面广告贴比较多的原因吧，我不太相信植发论坛里的帖子，也没怎么逛过植发论坛。主要了解植发技术和植发机构的渠道是知乎，还有就是亲身的考察。今年4月份，我在网上了解的基础上看了2家杭州的植发机构。通过对比，发现技术、价格上其实都差不多。再加上，中间认识到一位做过植发的本科师兄，了解了他的植发经历，也看了植发一年后的效果。最终确定在师兄做植发的这家机构做植发手术。时间就定在我实地考察2家医院的3周后——2016.04.23。&lt;/p&gt;

&lt;h2&gt;手术进行中&lt;/h2&gt;

&lt;p&gt;“铃铃铃~~~”，谁大早上的打电话？“*先生，你在路上了吗？”。。我擦，睡过头了。。&lt;/p&gt;

&lt;p&gt;好吧，这就是我手术当天的开始~ 史无前例高效的洗刷、穿衣、打车，还是晚了一个多小时才到医院。好在咨询医生人超好的帮我推迟了时间，还替我买了早餐。。只能说服务太周到了。与此同时，陷入2个闹钟都没被叫醒的深深自责中。。&lt;/p&gt;

&lt;p&gt;手术开始前，先剃了个板寸，也就剩一两毫米吧。然后洗了头，画了发际线，进入手术室。&lt;/p&gt;

&lt;p&gt;手术分为前后2个阶段，第一个阶段：取发；第二个阶段：植发。取发3个半小时，出来已经下午2点了。吃了饭，休息了大概半个多小时，重新进入手术室，进行下半程植发，一直到晚上8点半才结束，之前预测的手术时间在4、5个小时上，没想到这么久，据说是因为我自然卷的原因，取发比较慢，医生和我都累坏了。剩最后100单位的时候，还出现了个小意外，居然停电了，最后是在2部手机闪光灯的照射下完成了最后阶段的手术。&lt;/p&gt;

&lt;p&gt;手术过程中，最痛苦的过程是打麻药的过程。由于是局部麻醉，要覆盖到所有的取发区和植发区，所以光打麻药就被扎了几十针。在靠近耳朵和鬓角的位置，打麻药是非常疼的，因为神经比较集中。麻药生效后，头皮就感觉不是自己的了，所以一天被扎了几千针也没有什么特别的痛感。&lt;/p&gt;

&lt;p&gt;躺了一天，中间也不知道睡了醒，醒了睡反复了几次，最终手术宣告结束，植发3300+单位。&lt;/p&gt;

&lt;h2&gt;术后当晚&lt;/h2&gt;

&lt;p&gt;手术后已经接近晚上九点了，医院提供免费的住宿和饮食，就索性住下了。这里插一句，医院的服务和医生、护士的态度真的很好。他们的工作氛围也非常轻松愉快，还挺羡慕他们这种工作的感觉的。&lt;/p&gt;

&lt;p&gt;可能是因为做了鬓角的原因，当晚右前额+右眼，很疼，吃了止痛药也没啥作用。就是觉得又疼又困，后来迷迷糊糊很早就睡了。&lt;/p&gt;

&lt;h2&gt;术后前三天&lt;/h2&gt;

&lt;p&gt;到了术后第一天中午时分的样子，疼痛的感觉基本消除了。一夜不能翻身，枕着医院提供的U型枕睡了一晚，一个动作保持到天亮还挺累的。上午和住在一个房间的发友、护士聊聊天，下午换了纱布，在病房睡了一觉，然后就打道回府了。&lt;/p&gt;

&lt;p&gt;术后第二天，请假在家休养了一天。照镜子发现自己额头有三块地方明显陷进去了，而且是很明显的那种。回想一下，是手术过程中有医生一直负责用手指摁住我的额头的原因。当时心想，难不成以后就一直陷进去了，这医生指力如此过人，一看就不是俗人。第四天再看，凹陷已经完全恢复了，想想可能是因为水肿的原因。第三四天的时候，头顶明显发痒，一度有是在忍不住想去挠的冲动，还好忍住了。后来咨询医生，说是正常现象。痒了大概一两天，现在已经没啥感觉了。&lt;/p&gt;

&lt;p&gt;术后一堆要注意的事情，医生都会交代。主要是饮食、活动、洗头等方面的注意点。&lt;/p&gt;

&lt;p&gt;当前时间是术后第四天，简单谈谈自己感受。植发手术虽然是个简单微创手术，但是整个过程还是有点遭罪的。医院的医生护士服务态度都超级好，这点让我小感动，这也是最终选择这家医院的一个重要原因。目前来说效果还为时尚早，后续每隔一段时间更新下自己的状况吧。为自己记录下这次经历，也为同病相怜者提供一点借鉴。&lt;/p&gt;

&lt;p&gt;----------------------华丽丽的分割线，目前是术后第四天-----------------------&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>nodejs 中间件 & 插件</title>
     <link href="http://korbinzhao.github.io/middleware&plugins"/>
     <updated>2016-04-05T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/middleware&plugins</id>
     <content type="html">&lt;h2&gt;中间件&lt;/h2&gt;

&lt;p&gt;中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或 OS 环境。例如：IBM MQSeries，CICS/TXSeries&lt;/p&gt;

&lt;h3&gt;如何理解 &quot;中间件&quot; ?&lt;/h3&gt;

&lt;p&gt;我的理解是这样的，中间件就是类似于一个过滤器的东西，在客户端和应用程序之间的一个处理请求和响应的的方法。&lt;/p&gt;

&lt;p&gt;如果把一个http处理过程比作是污水处理，中间件就像是一层层的过滤网。每个中间件在http处理过程中通过改写request或（和）response的数据，状态，实现了特定的功能。&lt;/p&gt;

&lt;p&gt;以 koa 中间件为例：&lt;/p&gt;

&lt;p&gt;Koa的中间件很像Express的中间件，也是对HTTP请求进行处理的函数，但是必须是一个Generator函数。而且，Koa的中间件是一个级联式（Cascading）的结构，也就是说，属于是层层调用，第一个中间件调用第二个中间件，第二个调用第三个，以此类推。上游的中间件必须等到下游的中间件返回结果，才会继续执行，这点很像递归。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var koa = require('koa');
var http = require('http');
var app = koa();

app.use(function *(next){
 console.log('&amp;gt;&amp;gt; one');
 yield next;
 console.log('&amp;lt;&amp;lt; one');
});

app.use(function *(next){
 console.log('&amp;gt;&amp;gt; two');
 this.body = 'two';
 yield next;
 console.log('&amp;lt;&amp;lt; two');
});

app.use(function *(next){
  console.log('&amp;gt;&amp;gt; three');
  yield next;
  console.log('&amp;lt;&amp;lt; three');
});

http.createServer(app.callback()).listen(3000);

console.log('server start at port 3000');
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;插件&lt;/h2&gt;

&lt;p&gt;插件是一种遵循一定规范的应用程序接口编写出来的程序。很多软件都有插件，插件有无数种。例如在IE中，安装相关的插件后，WEB浏览器能够直接调用插件程序，用于处理特定类型的文件。IE浏览器常见的插件例如：Flash插件、RealPlayer插件、MMS插件、MIDI五线谱插件、ActiveX插件等等；再比如Winamp的DFX，也是插件。还有很多插件都是程序员新开发的。&lt;/p&gt;

&lt;h2&gt;组件&lt;/h2&gt;

&lt;p&gt;组件和插件的区别是，插件是属于程序接口的程序，组件在ASP中就是控件、对象，ASP/IIS的标准安装提供了11个可安装组件。ASP的FSO组件，编程的朋友都如雷贯耳吧，它就是最常用的Scripting.FileSystemObject对象。&lt;/p&gt;

&lt;h2&gt;套件&lt;/h2&gt;

&lt;p&gt;套件（package）Java提供package机制 ，它就像是一个管理容器，可以将您所定义的名称区隔管理在package下，而不会有相互冲突的发生，例如您定义了一个dimension2d与dimension3d的package，在它们之下都有一个Point类别，但由于属于不同的package，所以这两个名称并不会有所冲突。&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/bigbearbb/p/4221378.html&quot;&gt;大熊君大话NodeJS之------Connect中间件模块（第一季）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/enshrineZither/p/4093872.html&quot;&gt;中间件、插件、组件、套件之间的差别&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>字符编码扫盲及escape, encodeURI 和 encodeURIComponent方法比较</title>
     <link href="http://korbinzhao.github.io/comparing-escape-encodeURI-and-encodeURIComponent"/>
     <updated>2016-01-20T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/comparing-escape-encodeURI-and-encodeURIComponent</id>
     <content type="html">&lt;h2&gt;字符编码：ASCII，Unicode和UTF-8&lt;/h2&gt;

&lt;p&gt;在正式说转码之前，先了解下字符编码。下面是阮一峰网络日志的一篇文章的摘抄。&lt;/p&gt;

&lt;h3&gt;1.ASCII码&lt;/h3&gt;

&lt;p&gt;在计算机内部，所有的信息都最终表示为一个二进制字符串。每一个二进制（bit）有0和1两种状态，一个字节由8个二进制位组成，所以共256(2&lt;sup&gt;8&lt;/sup&gt;)种状态。&lt;/p&gt;

&lt;p&gt;ASCII码是定义了英文字符和二进制位之间关系的字符编码。ASCII码一共规定了128个字符的编码，比如空格是32（二进制00100000）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后7位，最前面一位统一规定为0；&lt;/p&gt;

&lt;h3&gt;2.非ASCII编码&lt;/h3&gt;

&lt;p&gt;英文用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。&lt;/p&gt;

&lt;p&gt;但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0--127表示的符号是一样的，不一样的只是128--255的这一段。&lt;/p&gt;

&lt;p&gt;至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。&lt;/p&gt;

&lt;h3&gt;3.Unicode&lt;/h3&gt;

&lt;p&gt;正如上一节所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。&lt;/p&gt;

&lt;p&gt;可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字表示的，这是一种所有符号的编码。&lt;/p&gt;

&lt;p&gt;Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样。&lt;/p&gt;

&lt;h3&gt;Unicode的问题&lt;/h3&gt;

&lt;p&gt;需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。&lt;/p&gt;

&lt;p&gt;比如，汉字&quot;严&quot;的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。&lt;/p&gt;

&lt;p&gt;这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。&lt;/p&gt;

&lt;p&gt;它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。&lt;/p&gt;

&lt;p&gt;转码问题是一个经常让人头疼的问题，下面比较下escape(), encodeURI() 和 encodeURIComponent()三种方法的不同以及使用场景。&lt;/p&gt;

&lt;h3&gt;5.UTF-8&lt;/h3&gt;

&lt;p&gt;互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。&lt;/p&gt;

&lt;p&gt;UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。&lt;/p&gt;

&lt;p&gt;UTF-8的编码规则很简单，只有二条：&lt;/p&gt;

&lt;p&gt;1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。&lt;/p&gt;

&lt;p&gt;2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
下表总结了编码规则，字母x表示可用编码的位。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Unicode符号范围(十六进制) | UTF-8编码方式（二进制）
--------------------|------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。&lt;/p&gt;

&lt;h2&gt;escape(), encodeURI() 和 encodeURIComponent()方法比较&lt;/h2&gt;

&lt;h3&gt;escape()方法&lt;/h3&gt;

&lt;p&gt;escape方法返回一个Unicode格式的字符串。所有的空格、标点符号、特殊字符和其他非ASCII字符都会被替换为%xx格式的编码，其中xx是相应字符的16进制数字。比如，一个空格会被转码为&quot;%20&quot;。&lt;/p&gt;

&lt;p&gt;该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： - _ . ! ~ * ' ( ) 。其他所有的字符都会被转义序列替换。&lt;/p&gt;

&lt;h3&gt;encodeURI()方法&lt;/h3&gt;

&lt;p&gt;encodeURI() 函数可把字符串作为 URI 进行编码。某些字符将被十六进制的转义序列进行替换。&lt;/p&gt;

&lt;p&gt;该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ' ( ) 。&lt;/p&gt;

&lt;p&gt;该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;amp;=+$,#&lt;/p&gt;

&lt;p&gt;注：
decodeURI(undefined) === 'undefined'; //true&lt;/p&gt;

&lt;h3&gt;encodeURIComponent()方法&lt;/h3&gt;

&lt;p&gt; encodeURIComponent() 函数 与 encodeURI() 函数的区别之处，前者假定它的参数是 URI 的一部分（比如协议、主机名、路径或查询字符串）。因此 encodeURIComponent() 函数将转义用于分隔 URI 各个部分的标点符号。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt; 通过对三个函数的分析，我们可以知道：escape()除了 ASCII 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对URL编码，最好不要使用此方法。而encodeURI() 用于编码整个URI,因为URI中的合法字符都不会被编码转换。encodeURIComponent方法在编码单个URIComponent（指请求参数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个URL。&lt;/p&gt;

&lt;h2&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html&quot;&gt;字符编码笔记：ASCII，Unicode和UTF-8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://xkr.us/articles/javascript/encode-compare/&quot;&gt;Comparing escape(), encodeURI(), and encodeURIComponent()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/qiantuwuliang/archive/2009/07/19/1526687.html&quot;&gt;escape()、encodeURI()、encodeURIComponent()区别详解&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>模拟form表单上传图片</title>
     <link href="http://korbinzhao.github.io/upload-image-simulate-post-form"/>
     <updated>2016-01-17T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/upload-image-simulate-post-form</id>
     <content type="html">&lt;p&gt;浏览器端：
html：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;form id=&quot;fileupload&quot; class=&quot;fileupload form-upload&quot; style=&quot;display:none;&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; action=&quot;javascript:;&quot; role = &quot;form&quot;&amp;gt;\
    &amp;lt;input type = &quot;file&quot; name = &quot;files&quot; class=&quot;file-input&quot; /&amp;gt; \
    &amp;lt;input type=&quot;hidden&quot; name=&quot;modulename&quot; value=&quot;&quot;/&amp;gt;\
    &amp;lt;input type=&quot;button&quot; class=&quot;upload-btn J_Uploadimg&quot;  value=&quot;上传截图&quot;/&amp;gt;\
&amp;lt;/form&amp;gt;\
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JS：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $fileUpload = $(&quot;.fileupload&quot;);

var formData = new FormData($fileUpload[0]);

    $.ajax({
        url: '/api/upload_img',
        type: 'POST',   
        data: formData,
        async: false,
        cache: false,
        contentType: false,
        processData: false,
        success: function(data){
            nanobar.go(100);
            //异步化
            if(data.success){
                $('#J_MsgCenter').html($.substitute('&amp;lt;span class=&quot;label label-success&quot;&amp;gt;{message}&amp;lt;/span&amp;gt;',{message:data.message}));
            }
            else{
                $('#J_MsgCenter').html($.substitute('&amp;lt;span class=&quot;label label-danger&quot;&amp;gt;{message}&amp;lt;/span&amp;gt;',{message:data.message}));
            }   
            node.removeClass('disabled');
            if(node.attr('data-reload')){
                window.location.reload();
            }
            console.log('imgUploader upload success, data:', data);
        },
        error: function(){
            $(&quot;#spanMessage&quot;).html(&quot;与服务器通信发生错误&quot;);
        }
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器端：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = function (req, res, next) {

new Promise(function(resolve, reject){

res.append('Access-Control-Allow-Origin', '*');

var form = new multiparty.Form();

form.parse(req, function(err, fields, files) {

  console.log('fields:');
  console.log(fields);

  console.log('files:');
  console.log(files);

  var modulename = fields.modulename[0];

  var modulePath = path.join(work_path, 'module', modulename);
  var imgPath = files.files[0].path;

  uploadImg(imgPath, modulePath, resolve, reject);

});

})
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>剪切板粘贴上传图片功能的实现</title>
     <link href="http://korbinzhao.github.io/clipboard-image-upload"/>
     <updated>2016-01-17T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/clipboard-image-upload</id>
     <content type="html">&lt;p&gt;平时的开发中我们难免要上传一些网页截图，传统的选择文件上传使用起来不方便，这里介绍一种使用js和node实现的剪切板黏贴上传图片功能。当我们需要上传截图时，只需手动截图后commond/ctrl+v即可完成图片上传。这种方式将大大减少我们在上传图片过程中花费的时间。&lt;/p&gt;

&lt;p&gt;要实现剪切板黏贴上传功能，首先我们要先能获取到在剪切板中的图片，这里给大家介绍一个很好用的js插件：&lt;a href=&quot;https://github.com/jorgenbs/ImageClipboard&quot;&gt;ImageClipboard&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;ImageClipboard&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/jorgenbs/ImageClipboard&quot;&gt;ImageClipboard&lt;/a&gt;是一款在chrome、firefox和opera上有效的可以将剪切板中的图片黏贴到网页上的工具。&lt;/p&gt;

&lt;h3&gt;安装&lt;/h3&gt;

&lt;p&gt;可以使用bower很简单的安装，如果没有安装bower，请先安装bower,安装使用说明见：&lt;a href=&quot;http://javascript.ruanyifeng.com/tool/bower.html&quot;&gt;bower：客户端库管理工具&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bower install image-clipboard
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;使用：将剪切板中的图片黏贴到网页中去&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot; src=&quot;ImageClipBoard.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;

 var clipboard = new ImageClipboard('#box', function (base64) {
    //do stuff with pasted image
 });

  //onpaste-callback can also be passed as second argument
  //in the constructor above.
 clipboard.onpaste = function (base64) {
    //do stuff with the pasted image
  });

  //you can also pass in single DOM-element instead of 
  //query as the first parameter.

&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  运行以上代码后，div#box中会插入一个img标签，src即为当前剪切板中图片。&lt;/p&gt;

&lt;h2&gt;剪切板中图片的获取与上传&lt;/h2&gt;

&lt;p&gt;通过ImageClipboard，我们可以以base64的形式获取到剪切板中的图片，然后将base64数据作为参数通过POST的方式传输到服务器端。&lt;/p&gt;

&lt;h3&gt;浏览器端代码：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;this.props.clipboard.onpaste = function (base64) {
  //do stuff with the pasted image
  //console.log(base64)

  $.ajax({
    url: 'http://localhost:2929/api/upload-img',
    dataType: 'JSON',
    data: {
      imgData: base64},
    type: 'POST',
    success: function(data) {
      console.log(data);
    }
  });

};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;服务器端代码&lt;/h3&gt;

&lt;p&gt;服务器端获取到base64数据，即可将base64数据转为图片存储或者传送到其他服务器。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export default function uploadImg(req, res) {

  new Promise((resolve, reject) =&amp;gt; {

    var fs = require('fs');
    var base64Data = req.body.imgData.replace(/^data:image\/png;base64,/, &quot;&quot;);

    fs.writeFile(&quot;out.png&quot;, base64Data, 'base64', function(err) {
      console.log(err);
    });  

  });

}
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>关于生活方式</title>
     <link href="http://korbinzhao.github.io/about-life-style"/>
     <updated>2015-11-23T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/about-life-style</id>
     <content type="html">&lt;p&gt;最近对生活方式有点感悟，正式因为意识到自己正拥有着一种槽糕的生活方式，并萌生了要改变的想法。&lt;/p&gt;

&lt;h2&gt;关于过去&lt;/h2&gt;

&lt;p&gt;平时工作累了，回到家往床上一躺，打开电脑这里点点那里点点，也不知道自己到底在干什么，时间飞快的过去。美其名曰是放空自己，实际上是一种彻头彻尾的逃避和浪费时间，想想这种方式只会让自己很消沉、沉浸在自己的情绪里难以自拔。浪费完时间，发现本来可以做的事情一件都没做，于是自己又陷入一种紧张感，让自己永远生活在一种紧迫之中。&lt;/p&gt;

&lt;p&gt;这种状态从研三到现在已经持续了相当长一段时间了。或许是自己的内心太不强大，或许是太不会一个人生活。无论是什么原因，其实都迫切需要解决，不能期待他人拯救，只能自我救赎。&lt;/p&gt;

&lt;p&gt;我习惯的状态是怎样的呢？彻彻底底的放空自己，什么都不想，什么都不面对。如果可以一直这样倒还挺好。但是现实是我们都不得不回到现实，照照镜子要面对自己，在公司要面对工作中的琐事。。一颗懒散疲惫的心得不到正确的放松和休息，只会让自己陷入恶性循环。&lt;/p&gt;

&lt;p&gt;这就是我经历着的过去。&lt;/p&gt;

&lt;h2&gt;关于快乐&lt;/h2&gt;

&lt;p&gt;其实大多数人都知道生活的本质就是快乐。但是正如《后会无期》里的一句台词：“听过很多道理，依然过不好这一生。” 我很想时时刻刻快乐，但是事实好像并不如人意。&lt;/p&gt;

&lt;p&gt;回想过去快乐的时光，全部都是和朋友们一起的时光。我怀念2011年的夏天，在中山实习的短短1个月，让我彻底忘却所有烦恼，心中没有一丁点的负担，不会为过去做的窘事懊恼，不会对未来担忧。每一分每一秒都是纯粹的开心。快乐到已经忘却整个世界，或者是觉得当时的生活就是整个世界。这或许就是朋友和陪伴的力量，那种轻松和自在是我自从初中开始就从未拥有过的。十年寒窗的坚持让我习惯了用一种苦涩去面对现实和未来，我仿佛失去了快乐的能力。感谢那个夏天让我重拾了快乐的能力，感谢那时陪在我身边的人。我怀念工作后浙西大峡谷的自驾行，虽然只发生在不久前，虽然作为一个闪亮的灯泡照耀在两对情侣身边，但是很感谢有两位即使有女朋友依旧没有忘记我的朋友，我感受到被朋友重视的感觉，我很珍惜和你们在一起的每分每秒。我怀念PD邀请一群工作伙伴一起吃的一顿饭，让我感受到你们生活的精致和追求，让我感受到和不同岗位一伙伴一起交流的乐趣。。这个世界很大，有趣的人太多，不落单的时光才是快乐的时光。&lt;/p&gt;

&lt;p&gt;当我独立面对自己，总会陷入一种难以自拔的窘境。所以我说，我太不会一个人生活。我只会用懒散的状态去放空自己，计划中的事情总是拖到不能再拖的时候才会去做，最后白白浪费大量空闲时间。等到突然意识到一大堆事情没做的时候，又会更加加剧自己的焦躁心理，从而陷入一种恶性循环。这是一个可怕的循环，我现在正在反复经历着。每当独处的时候都会很不快乐，以上分析就是现在这种糟糕状态的根本原因。&lt;/p&gt;

&lt;p&gt;只有跳出这个循环，只有充分利用这些空闲时间，你才能活出自己的生活，积累出超出别人的工作成绩。如果这种状态不改变，只能一直平凡、平庸下去。&lt;/p&gt;

&lt;h2&gt;关于生活方式&lt;/h2&gt;

&lt;p&gt;上一节里分析了我为什么独处的时候那么不快乐。那么到底要怎样摆脱这种恶性循环呢。我能想到的答案就是生活方式的一种改变，或者说是一种习惯的养成。&lt;/p&gt;

&lt;h3&gt;晚上回家后，不管多累先洗澡&lt;/h3&gt;

&lt;p&gt;现在的现状是每天一回家，累得浑身好像一点力气都没有，浑身的疲累和一脸的油全然不顾，就往床上一躺，打开电脑开始漫无目的的上网、看视频，最后时间飞快的到了12点多，然后洗个澡，然后又变精神了，最后折腾折腾，不到1点半肯定是没法安心入睡的，第二天一觉睡到九点多挣扎着起来，上班的时候也没啥精神。这是一个很坏的习惯，浪费了时间，养成了坏的作息习惯，也不利于身体健康。&lt;/p&gt;

&lt;p&gt;所以回到家后，先洗澡，让自己从疲劳的状态中暂时精神起来，然后就可以把今天的工作整理整理，文章写一写，运动做一下。最后累了，躺在床上安然入睡。&lt;/p&gt;

&lt;h3&gt;床只能是睡觉的地方。躺在床上玩电脑，玩手机，赖床这种行为绝对禁止。&lt;/h3&gt;

&lt;p&gt;为什么每天很晚才能睡着，很重要的一个原因是回到家后，基本大部分行为都是在床上完成的，比如看视频，玩手机游戏。玩手机、看视频本身就是让人精神亢奋的事情，当然很难入睡，长期养成条件反射行为，人一到床上就兴奋的没有睡意，而不是一沾枕头就着。&lt;/p&gt;

&lt;h3&gt;椅子靠背不许用。&lt;/h3&gt;

&lt;p&gt;之前的一个很大的坏习惯是每次坐在椅子上其实都只能用“瘫坐”这个词来形容。仿佛没有脊椎一样，一定要靠在椅背上才算舒服。但是长时间靠椅背会让人很快进入疲劳状态还不自觉，瘫坐在椅子上很长时间，虽然很累，却也懒得起来活动一下。长时间的瘫坐在椅子上，还会形成弯腰驼背，容易得脊椎病。直挺挺的坐在椅子上恰恰相反，脊椎会利用自身的自然弯曲分散上身重量，久坐也不易感觉疲累，更不会弯腰驼背，累了也会很自然的站起来活动，不会有倦怠心理，连站起来活动都懒得做（这种行为和赖床也有点像，躺在床上越累越不愿起来）。&lt;/p&gt;

&lt;h2&gt;关于行动&lt;/h2&gt;

&lt;p&gt;其实不大好意思说“行动”这个词，因为每次给自己定一个计划，大多数情况最后都不了了之了。但是这次，我想说：“我是认真的，因为我意识到了问题的严重性。”&lt;/p&gt;

&lt;p&gt;后面我会每周过来更新下状态，记录下执行情况。虽然我知道这篇文章也不会有几个人看到。毕竟是自己写给自己的。&lt;/p&gt;

&lt;p&gt;----------- 2015-11-23 -----------&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>和PD、运营、设计师和用研们的一顿饭</title>
     <link href="http://korbinzhao.github.io/a-meal-with-colleagues"/>
     <updated>2015-11-16T00:00:00+08:00</updated>
     <id>http://korbinzhao.github.io/a-meal-with-colleagues</id>
     <content type="html">&lt;p&gt;受PD的邀请，今晚一帮同事去她家做客。去之前，其实心里很是忐忑，自己面对一帮陌生人总会多多少少有些逃避的心理。但是理智告诉我，还是必须得去的，虽然平时工作很忙，经常陷入某个难缠的bug好久，让自己越发的有些寡言少语。一来这不是我想要的状态，二来长此以往是非常不健康的。&lt;/p&gt;

&lt;h2&gt;经过&lt;/h2&gt;

&lt;p&gt;去之前买了点水果带过去，否则空着手去做客太说不过去了。幸好买了，其实大家过去也都多多少少带了些东西，比如水果、红酒。PD家离我住的地方倒也非常近，打了车5分钟就到小区门口了，从小区门口进去一直走，穿过漆黑一片的小路，最近好不容易找到PD的家。&lt;/p&gt;

&lt;p&gt;小区配套挺差的，连个路灯都没开，附近可以吃饭消遣的地方看起来也不多。但是，已进入房间，顿时眼前一亮，装修不同，真的可以给同样的房子带来完全不同的感觉。超大的客厅（把原来的客厅和一个卧室打通连在一起），客厅中间放着沙发、对面是超大的电视屏幕，后面是一张很大的工作长桌，客人多的时候可以用来当做餐桌（当然，这次就是这样做的），房间内到处都是简约却充满文艺气息的装饰品，房子位于顶楼，复式结构，二楼虽然只是楼顶屋檐下面的一点空间，但是布局合理，丝毫没有压抑的感觉，而且还有2个天窗，天气好的时候抬头就可以看到星星。一句话总结，这房子完全像是设计师精心设计过的房子，但是事实上只是房子的主人——另一个PD的设计，果然是一个充满设计师气质的PD。&lt;/p&gt;

&lt;p&gt;晚饭完全有一个帅帅的运营下厨，扬州人，之前还合作过，其实想说我和扬州还有些渊源，后来忍住没说。最后7点半，前前后后到了有十来个人。晚餐超级丰盛，三文鱼、酸菜鱼、蒜蓉油虾、香橙鸡肉沙拉、啤酒红烧肉、红焖茄子、蒜炒白菜、毛豆米、拍黄瓜、焗海蟹、烤鸡翅、各种糕点。。。我只想说城里人真会吃。还没开始吃饭，下厨的运营就开了一瓶红酒，其他人根据自己喜好选择红酒、果汁。席间还尝试了“peng”一下的喝法，就是用一种叫不出名字的国外的白酒兑上雪碧，手掌按住杯口，往桌子上猛地一按，“peng”的一下，然后往酒里撒点盐，一饮而尽。第一次尝试这种喝法，还挺爽的。&lt;/p&gt;

&lt;h2&gt;感想&lt;/h2&gt;

&lt;p&gt;其实呢，之所有有冲动把简单的一顿饭写出来，就是想谈谈感受。在技术团队待久了，每天对着电脑敲代码，需要说话的场景不是很多，再加上技术团队整体在性格上会比较沉闷，在生活品质和乐趣上的追求也没有其他团队那么多。让我这段时间总感觉有些无聊，心情莫名低落，即使好不容易有点时间也宁愿宅着，有一种非常懒散拖延的状态。这种状态于工作、于生活都不是太好的。所以这里提醒下自己，多走出去，多和不同背景、不同岗位的人交流，这不仅有利于拓宽自己的视野，也会让自己更开心一点。正如今天的这次简单的聚会，虽然去之前略感忐忑，去之后却感觉很享受这个过程，每个人仿佛都有着自己独特的故事、自己独特的生活乐趣，这也是我想经历和正在追求的。&lt;/p&gt;

&lt;p&gt;另外，和有趣的人一起，你也会变得有趣。现在的我有点太无聊了，自己都受不了自己。我需要和有趣的人在一起。&lt;/p&gt;
</content>
   </entry>
   
 
</feed>
