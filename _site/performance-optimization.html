<!DOCTYPE html>
<html>
<head>
    <!--
    * Author:         Joebon
    -->
    <meta charset="utf-8" />
    <title>无线性能优化 | Joebon's world</title>
    <meta name="author" content="Joebon" />
    <meta name="renderer" content="webkit">
    <meta name="description" content="Joebon's Blog" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="stylesheet" href="/css/default.css" type="text/css" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/atom.xml" />
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
</head>
<body>

    <div class="home-menu">
        <div class="home-icon-con">
            <a class="home-menu-icon" href="/">Joebon</a>
            <a class="home-follow" href="#" title="Contact Me">+</a>
        </div>
        <div class="home-contact">
            <a href="http://weibo.com/zbin1202/" target="_blank" style="margin-left:-5px;"><img src="http://www.weibo.com/favicon.ico" alt="" width="25"/></a>
            <a href="http://www.douban.com/people/korbinzhao/" target="_blank" style="text-align:center;"><img src="http://www.douban.com/favicon.ico" alt="" width="22"/></a>
            <!-- <a href="http://instagram.com/beiyuu/" target="_blank" style="text-align:right"><img src="http://d36xtkk24g8jdx.cloudfront.net/bluebar/00c6602/images/ico/favicon.ico" alt="" width="22"/></a> -->
        </div>
    </div>

    <link rel="stylesheet" href="/js/prettify/prettify.css" />
<style type="text/css">
    body { background:#e8e8e8; }
    @media screen and (max-width: 750px){
        body { background:#fff; }
    }
    @media screen and (max-width: 1020px){
        body { background:#fff; }
    }
</style>

<div id="content">
    <div class="entry">
        <h1 class="entry-title"><a href="/performance-optimization" title="无线性能优化">无线性能优化</a></h1>
        <p class="entry-date">2016-05-11</p>
        <p>无线性能优化可分为“加载性能”、“渲染性能”、“感知性能”。</p>

<h2>加载性能</h2>

<p>我们在谈到加载性能时，一般关注的是页面的首屏加载速度。</p>

<h3>webp</h3>

<p><a href="https://developers.google.com/speed/webp/">WebP</a>，是一种支持有损压缩和无损压缩的图片文件格式。根据 Google 官方的数据，无损压缩后的 WebP 比 PNG 文件少了 26％ 的文件大小，有损压缩在具有同等SSIM索引的情况下WebP 比 JPEG 文件少25-34%的文件大小。</p>

<h3>iconfont</h3>

<p>iconfont 对于前端来说有很多优点，自由变化大小、矢量不失真、自由修改颜色、可以添加一些视觉效果，如阴影、旋转、透明度，兼容 IE6.</p>

<p>可通过 <a href="http://www.iconfont.cn/">iconfont</a> 平台使用，使用格式如下：</p>

<pre><code>    @font-face {
        font-family: "iconfont";
        src: url('iconfont.eot'); /* IE9*/
        src: url('iconfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */
        url('iconfont.woff') format('woff'), /* chrome、firefox */
        url('iconfont.ttf') format('truetype'), /* chrome、firefox、opera、Safari, Android, iOS 4.2+*/
        url('iconfont.svg#iconfont') format('svg'); /* iOS 4.1- */
    }
</code></pre>

<p>在移动端，目前只需引用一个 ttf 文件。</p>

<pre><code>    @font-face {
        font-family: "iconfont";
        src: url('iconfont.ttf') format('truetype');
    }
</code></pre>

<p>小于 10K 的 ttf 文件建议 base64 在 css 文件中。例如：</p>

<pre><code>    @font-face {
        font-family: "iconfont";
        src: url('data:application/x-font-ttf;base64,AAEAAAAPAIAAAwBwRkZUTXCKsTYAAAD8AAAAHE9TLzJWulwpAAABGAAAAGBjbWFwzCYhagAAAXgAAAFKY3Z0IAyV/7YAAAmUAAAAJGZwZ20w956VAAAJuAAACZZnYXNwAAAAEAAACYwAAAAIZ2x5Zn46oOwAAALEAAADyGhlYWQHSlJcAAAGjAAAADZoaGVhBzID5wAABsQAAAAkaG10eAq0AM4AAAboAAAAFGxvY2EBjAI0AAAG/AAAAAxtYXhwAScKKwAABwgAAAAgbmFtZQV/3xUAAAcoAAACLnBvc3RMkaPUAAAJWAAAADRwcmVwpbm+ZgAAE1AAAACVAAAAAQAAAADMPaLPAAAAANImhzMAAAAA0iaHMwAEA/QB9AAFAAACmQLMAAAAjwKZAswAAAHrADMBCQAAAgAGAwAAAAAAAAAAAAEQAAAAAAAAAAAAAABQZkVkAMAAeOZFAyz/LABcAxgAHwAAAAEAAAAAAxgAAAAAACAAAQAAAAMAAAADAAAAHAABAAAAAABEAAMAAQAAABwABAAoAAAABgAEAAEAAgB45kX//wAAAHjmRf///4sZvwABAAAAAAAAAAABBgAAAQAAAAAAAAABAgAAAAIAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAIgAAATICqgADAAcAKUAmAAAAAwIAEErLbBDLLIAADorLbBELLIAATorLbBFLLIBADorLbBGLLIBATorLbBHLLIAADsrLbBILLIAATsrLbBJLLIBADsrLbBKLLIBATsrLbBLLLIAADcrLbBMLLIAATcrLbBNLLIBADcrLbBOLLIBATcrLbBPLLIAADkrLbBQLLIAATkrLbBRLLIBADkrLbBSLLIBATkrLbBTLLIAADwrLbBULLIAATwrLbBVLLIBADwrLbBWLLIBATwrLbBXLLIAADgrLbBYLLIAATgrLbBZLLIBADgrLbBaLLIBATgrLbBbLLAwKy6xJAEUKy2wXCywMCuwNCstsF0ssDArsDUrLbBeLLAAFrAwK7A2Ky2wXyywMSsusSQBFCstsGAssDErsDQrLbBhLLAxK7A1Ky2wYiywMSuwNistsGMssDIrLrEkARQrLbBkLLAyK7A0Ky2wZSywMiuwNSstsGYssDIrsDYrLbBnLLAzKy6xJAEUKy2waCywMyuwNCstsGkssDMrsDUrLbBqLLAzK7A2Ky2waywrsAhlsAMkUHiwARUwLQAAS7gAyFJYsQEBjlm5CAAIAGMgsAEjRCCwAyNwsA5FICBLuAAOUUuwBlNaWLA0G7AoWWBmIIpVWLACJWGwAUVjI2KwAiNEswoJBQQrswoLBQQrsw4PBQQrWbIEKAlFUkSzCg0GBCuxBgFEsSQBiFFYsECIWLEGA0SxJgGIUVi4BACIWLEGAURZWVlZuAH/hbAEjbEFAEQAAAA=') format('truetype');
    }
</code></pre>

<h3>sprite 图片</h3>

<p>Sprite 图片（又称：雪碧图）被运用在众多使用了很多小图标的网站上。sprite 图将众多小图标集成到一张图片上。通过减少请求数提升了性能。在移动端，使用雪碧图时也要注意图片尺寸不能过大，因为图片越大，解码内存消耗就越大，如果过大反而会影响性能。</p>

<p>解码内存消耗（decoded in memory)的计算公式： （w x h x 4）宽 x 高 x 每个像素4个字节数</p>

<p>如果设备 DPI 大于1，还需要乘以 DPI 系数，如 Retina 设备 乘以 4 ，RetinaHD 设备乘以 9.</p>

<p><img src="http://gtms02.alicdn.com/tps/i2/TB11_q7HVXXXXbTXVXXWwRTPpXX-1577-730.png" alt="" /></p>

<p>考虑到解码内存消耗，合理的生成紧凑的 Sprite 图，既可以带来更少的请求数，又可以保证尽量低的消耗。</p>

<h3>按需加载</h3>

<h2>渲染性能</h2>

<h3>设备刷新率</h3>

<p>设备刷新率是影响我们对于页面滚动、动画流畅性感知的重要参数。</p>

<p>页面运行在设备的浏览器中，现在市面上的移动设备的刷新频率大多是 60次/秒。所以给浏览器渲染每一帧画面的时间应该是（1s/60=16.67ms）。</p>

<p>实际上，浏览器并不是把所有时间都花在页面渲染上，还需要做诸如渲染队列管理、不同线程切换等额外工作。所以单纯的浏览器渲染工作留给我们的时间也就是10ms左右。当每一帧渲染操作的时间大于这个时间时，页面就会表现的比较卡顿。</p>

<h3>浏览器的页面渲染流程</h3>

<ol>
<li>HTML。根据服务器端的 HTML 代码，形成文档对象模型（DOM）</li>
<li>Style。 加载并解析样式，形成 CSS 对象模型</li>
<li>Layout。在文档对象模型和 CSS 对象模型基础上，生成一颗由一组待生成渲染的对象组成的渲染树;对渲染树上的每个元素，计算其坐标，称之为布局</li>
<li>Paint。渲染树上的元素最终展现在浏览器上，称之为“painting”。一般来说，这个绘制过程是在多个层上完成</li>
<li>Composite。由上一步可知，对页面中 DOM 元素的绘制时在多个层上进行的。在每个蹭上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。</li>
</ol>


<h3>如何排查渲染性能问题</h3>

<p>首先使用 chrome 的 Timeline ，滚动页面，进行 record 。得到如下结果，其中绿色的波浪线就是页面的帧率。</p>

<p><img src="https://img.alicdn.com/tps/TB1JXsbLFXXXXafaXXXXXXXXXXX-712-74.png" alt="" /></p>

<p>其中波浪线越高表示帧率越高，同时，帧率区域上边标红的一行，表示有问题的帧。</p>

<p>逐一排查标红的帧。</p>

<p><img src="https://img.alicdn.com/tps/TB1c2cXLFXXXXbaaXXXXXXXXXXX-531-247.png" alt="" /></p>

<p>然后，点击选中该帧，可以看到详细的耗时和简单的问题描述。</p>

<p><img src="https://img.alicdn.com/tps/TB1jZH6LFXXXXakapXXXXXXXXXX-572-256.png" alt="" /></p>

<p>本例中，该帧耗时过长，会导致卡顿。</p>

<h4>JS 分析</h4>

<p>发现了运行时间很长的 JS 代码，那么你可以开启 DevTools 中顶部的 JS Profiler 选项：</p>

<p><img src="https://img.alicdn.com/tps/TB1UtwrLFXXXXcXXpXXXXXXXXXX-307-88.jpg" alt="" /></p>

<p>开启后，会看到更多细节：</p>

<p><img src="https://img.alicdn.com/tps/TB1Tp.pLFXXXXcOXpXXXXXXXXXX-766-462.png" alt="" /></p>

<p>其中，浅绿色的为函数调用的链路，更详细的，可以切换至 Call Tree 的 Tab 页：</p>

<p><img src="https://img.alicdn.com/tps/TB1fyMbLFXXXXX9aXXXXXXXXXXX-760-283.png" alt="" /></p>

<h4>render 分析</h4>

<p>render 部分包括 Recalculate Style 和 Layout ，如果发现 render 部分耗时过长，需要分别从这两部分进行分析。</p>

<p>如果某一帧触发了强制 layout ， Timeline 会用红色角标标出:</p>

<p><img src="https://img.alicdn.com/tps/TB1lEEELFXXXXXbXXXXXXXXXXXX-507-174.png" alt="" /></p>

<p>如何需要具体分析 Recalculate Style ， 可以选中 Recalculate Style 部分，下面详细列出了受影响的元素个数、触发 Recalculate Style 函数一级警告提示：</p>

<p><img src="https://img.alicdn.com/tps/TB1NCIsLFXXXXbjXpXXXXXXXXXX-853-216.png" alt="" /></p>

<p>更加直观的函数调用，可以切换至 Bottom-Up 的 Tab 页，来查看逆向的调用，方便定位触发的函数位置：</p>

<p><img src="https://img.alicdn.com/tps/TB1KBEALFXXXXbsXXXXXXXXXXXX-812-169.png" alt="" /></p>

<p>如果需要分析 Layout ，可以选中 Layout 部分，同 Recalculate Style 一样。</p>

<h4>paint 分析</h4>

<p>你可以选中 Timeline 中绿色的 paint 部分：</p>

<p><img src="https://img.alicdn.com/tps/TB1hUMnLFXXXXagXFXXXXXXXXXX-573-574.png" alt="" /></p>

<p>summary 会展示绘制的总体情况，包括绘制的元素、元素本身绘制耗时、元素子元素绘制耗时。</p>

<p>更加详细的信息，可以切换至 Paint Profiler ，包括了每个具体 Paint 的调用和 Paint 区域截图：</p>

<p><img src="https://img.alicdn.com/tps/TB15bUeLFXXXXbEXVXXXXXXXXXX-736-348.png" alt="" /></p>

<h4>composite 分析</h4>

<p>分析 composite （合成）时，需要选中一帧：</p>

<p><img src="https://img.alicdn.com/tps/TB1sar9LFXXXXcWaXXXXXXXXXXX-680-119.png" alt="" /></p>

<p>点击这个 Layers 选项卡，你会看到一个新的视图。在这个视图中，你可以对这一帧中的所有渲染层进行扫描、缩放等操作，同时还能看到每个渲染层被创建的原因：</p>

<p><img src="https://img.alicdn.com/tps/TB1yV7uLFXXXXaMXpXXXXXXXXXX-979-356.png" alt="" /></p>

<p>有了这个视图，你就能知道页面中到底有多少个渲染层。如果你在对页面滚动或者渐变效果的性能分析中发现渲染层的合并过程耗费了太多时间（相对于4-5毫秒的预期），那么久可以从这个视图中看到页面中有多少个渲染层，何时被创建，从而对渲染层的数量进行优化。</p>

<h3>Script - 优化JS的执行效率</h3>

<p>错误的执行时机和太长的时间消耗是常见的导致 JS 性能低下的原因。</p>

<h4>概要</h4>

<ul>
<li>对于动画效果的实现，避免使用 setTimeout 或 setInterval ，请使用 requestAnimationFrame。</li>
<li>把耗时的 JS 代码放到 Web Workers 中去做。</li>
<li>把 DOM 元素的更新划分为多个小任务，分别在多个 frame 中去完成。</li>
<li>使用 Chrome DevTools 的 Timeline 和 JS Profiler 来分析 JS 的性能。</li>
</ul>


<h4>使用 requestAnimationFrame</h4>

<p>window.requestAnimationFrame 是一个专门为动画而生的 web API 。它通过浏览器在页面重回前执行你的回调函数。通常来说被调用的频率是每秒60次。</p>

<p>很多框架和示例代码都是用 setTimeout 或 setInterval 来实现页面的动画效果，比如 jQuery 中的 animation。这种实现方式的问题是，你在 setTimeout 或者 setInterval 中指定的回调函数的执行时机是无法保证的。他将在这一帧动画的某个时间点被执行，很可能是在帧结束的时候。这就意味着我们可能失去这一帧的信息。</p>

<p><img src="https://segmentfault.com/img/bVvdhN" alt="" /></p>

<p>requestAnimationFrame 的其他高能用法</p>

<ul>
<li>动画： 也是它的主要用途，它将我们动画的执行时机和执行频率交由浏览器决定，以得到更好的性能。</li>
<li><p>函数节流：requestAnimationFrame 的执行频率（一帧）是16.67ms，利用这一特性就可以做到函数节流，避免高频事件在一帧内做多与的无用功的函数执行，例如：</p>

<pre><code>  var $box = $('#J_Test'),
  $point = $box.find('b');
  $box.on('mouseenter',function(e){
  requestAnimationFrame(function(){
          $point.css({
              top : e.pageY,
          left : e.pageX
          })
      });
  });
</code></pre></li>
<li><p>分帧初始化：同样利用一帧的执行时间将模块的初始化或渲染函数分散到不同的帧中来执行，这样每个模块都有16.67ms的执行时间，而不是一股脑的堆在哪里等着执行。</p>

<pre><code>      var rAF = window.requestAnimationFrame ||  window.webkitRequestAnimationFrame ||
      function(c) {
          setTimeout(c, 1 / 60 * 1000);
      };

      function render() {
      self.$container.html(itemHtml);
      self.$container.find('.J_LazyLoad').lazyload();
      }

      rAF(render);
</code></pre></li>
</ul>


<h4>使用 transform 实现动画 （待定）</h4>

<p>css transition 是我们在实现一个动画是能够想到的最简单的一种实现方式。但是当频繁操作样式时，也会出现动画不怎么流畅的问题。</p>

<p>解决这一问题的一个方式就是使用 transform 来实现相同的效果：</p>

<pre><code>transition: left 2s ease-in-out;  ---&gt; transition: transform 2s ease-in-out;
left: xxx; ---&gt; transform: translate3d(xxx, yyy, zzz);
</code></pre>

<h4>硬件（GPU）加速</h4>

<p>硬件（GPU）加速，即层的合成（layer composite）。我们常说的使用 translate3D 开启硬件加速，其实是使应用了 translate3D 的元素获得独立的 GraphicsLayer，好处如下：</p>

<ul>
<li>每个 GraphicsLayer 都有一个 GraphicsContext， GraphicsContext 会输出该层的位图，交由 GPU 合成，比 CPU 要快</li>
<li>当需要 repaint 时，只要 repaint 自己，不会影响到其他的 GraphicsLayer 。 repaint 完后，只需要通过 GPU 同其它层合并下（composite layers）</li>
</ul>


<p>所以，在我们平常做动态效果时，会使用 translate3D 的 hack ，利用 GPU 的合成来获取更好的效果和性能。</p>

<p>传统方式下，浏览器依赖于 CPU 来渲染页面内容。而随着 GPU 硬件能力的不断发展，开始试图使用 GPU 的硬件能力来获得更好的性能和更少的电量消耗。使用 GPU 来渲染合成页面内容可以获得明显的速度提升。</p>

<h5>合成器</h5>

<p>chrome 合成器（Compositor）是一个软件库，用来管理 GraphicsLayer 树。</p>

<h5>GPU</h5>

<p>合成器会使用 GPU 来执行它的合成绘制步骤。在硬件加速体系结构中，合成由 GPU 负责。合成器本质上也是使用 GPU 将层绘制成一个位图，最后输出到屏幕上。</p>

<h4>降低代码复杂度或者使用 Web Workers</h4>

<p>JS 代码是运行在浏览器的主线程上的。与此同时，浏览器的主线程还负责样式计算、布局，甚至绘制的工作。如果 JS 代码运行时间过长，就会阻塞主线程上其他的渲染工作，很可能就会导致帧丢失。</p>

<p>大多数情况下，可以把纯计算工作放在 Web Workers 中（如果这些计算工作不会涉及 DOM 操作）。一般来说， JS 中数据的处理工作，比如排序或搜索，一般都适合这种处理方式。</p>

<pre><code>var dataSortWorker = new Worker("sort-worker.js");
dataSortWorker.postMesssage(dataToSort);

// The main thread is now free to continue working on other things...

dataSortWorker.addEventListener('message', function(evt) {
var sortedData = e.data;
// Update data on screen...
});
</code></pre>

<p>如果 JS 代码需要存取 DOM 元素，也就是说必须在主线程上运行，可以考虑批处理的方式：把任务细分为若干个小任务，每个小任务耗时很少，各自放在一个 requestAminationFrame 中回调运行。</p>

<pre><code>var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);
requestAnimationFrame(processTaskList);

function processTaskList(taskStartTime) {
    var taskFinishTime;

    do {
    // Assume the next task is pushed onto a stack.
    var nextTask = taskList.pop();

    // Process nextTask.
    processTask(nextTask);

    // Go again if there’s enough time to do the next task.
     taskFinishTime = window.performance.now();
    } while (taskFinishTime - taskStartTime &lt; 3);

    if (taskList.length &gt; 0)
    requestAnimationFrame(processTaskList);

}
</code></pre>

<p>如果采用划分小任务的方式，那么需要确保给用户一个好的 UX/UI，使得用户能够感知到当前浏览器正在处理一个任务，比如一个进度条或者指示器。</p>

<h4>避免对 JS 代码进行微优化</h4>

<p>对于一个任务，如果换一种实现方式，浏览器的执行速度可以快100倍，这是非常酷的。比如读取一个元素的 offsetTop 属性就比计算它的 getBoundingClientRect() 要快。但一般情况下，在微优化上花再大的精力，整体上 JS 代码的性能也就获得若干毫秒的提升。这是不划算的。</p>

<p>简而言之：慎用微优化。因为一般来说，它对你的 web 应用效果不大。</p>

<h3>Style - 降低样式计算和复杂度</h3>

<h3>Layout - 避免大规模、复杂布局</h3>

<p>尽可能避免触发布局</p>

<h3>Paint</h3>

<p>如果触发了 Layout，那么一定会触发 Paint。这个很好理解，修改了元素的几何属性意味着元素要重新渲染，除此之外，改变元素的一些非几何属性，比如：背景、颜色、阴影等，不会触发 Layout，但是依然会触发 Paint。</p>

<h3>composite</h3>

<p>提升为合成层简单说来有以下几点好处：</p>

<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
<li>对于诸如 fixed 的合成层，移动时不会触发 repaint</li>
</ul>


<p>利用合成层对于提升页面性能方面有很大的作用，因此我们也总结了一下几点优化建议。</p>

<ul>
<li>提升动画效果的元素</li>
<li>使用 transform 或者 opacity 来实现动画效果</li>
<li>减少绘制区域</li>
<li><p>合理管理合成层</p>

<p>  看完上面的文章，你会发现提升合成层会达到更好的性能。这看上去非常诱人，但是问题是，创建一个新的合成层并不是免费的，它得消耗额外的内存和管理资源。实际上，在内存资源有限的设备上，合成层带来的性能改善，肯能远远赶不上过多合成层开销给页面性能带来的负面影响。同时，由于每个渲染层的纹理都需要上传到 GPU 处理，因此我们还需要考虑 CPU 和 GPU 之间的带宽问题、以及有多大内存供 GPU 处理这些纹理的问题。</p></li>
<li><p>防止层爆炸</p>

<p>  通过之前的介绍，我们知道同合成层重叠也会使元素提升为合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况。也就是说除了我们显式的声明的合成层，还可能由于重叠原因不经意间产生一些不在预期的合成层，极端一点可能会产生大量的额外合成层，出现层爆炸的现象。</p></li>
</ul>


<h2>参考资料</h2>

<ol>
<li><a href="https://segmentfault.com/a/1190000005017600">无线页面动画优化实例</a></li>
<li><a href="https://developers.google.com/speed/webp/">WebP</a></li>
<li><a href="http://www.iconfont.cn/">iconfont</a></li>
<li><a href="https://developer.chrome.com/devtools/docs/timeline">chrome devtool timeline</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/rendering/?hl=zh-cn">google render performance</a></li>
</ol>



        <!--<div id="disqus_container">-->
            <!--<div style="margin-bottom:20px" class="right">-->
                <!--<script type="text/javascript" charset="utf-8">-->
                <!--(function(){-->
                  <!--var _w = 86 , _h = 16;-->
                  <!--var param = {-->
                    <!--url:location.href,-->
                    <!--type:'6',-->
                    <!--count:'', /**是否显示分享数，1显示(可选)*/-->
                    <!--appkey:'', /**您申请的应用appkey,显示分享来源(可选)*/-->
                    <!--title:'', /**分享的文字内容(可选，默认为所在页面的title)*/-->
                    <!--pic:'', /**分享图片的路径(可选)*/-->
                    <!--ralateUid:'1742737645', /**关联用户的UID，分享微博会@该用户(可选)*/-->
                    <!--language:'zh_cn', /**设置语言，zh_cn|zh_tw(可选)*/-->
                    <!--rnd:new Date().valueOf()-->
                  <!--}-->
                  <!--var temp = [];-->
                  <!--for( var p in param ){-->
                    <!--temp.push(p + '=' + encodeURIComponent( param[p] || '' ) )-->
                  <!--}-->

                  <!--document.write('<iframe allowTransparency="true" frameborder="0" scrolling="no" src="http://hits.sinajs.cn/A1/weiboshare.html?' + temp.join('&') + '" width="'+ _w+'" height="'+_h+'"></iframe>')-->
                <!--})()-->
                <!--</script>-->
            <!--</div>-->
            <!--&lt;!&ndash; <a href="#" class="comment" onclick="return false;">点击查看评论</a> &ndash;&gt;-->
             <!--<div id="disqus_thread"></div>-->
        <!--</div>-->

      <!-- 多说评论框 start -->
      <div class="ds-thread" data-thread-key="/performance-optimization" data-title="无线性能优化" data-url="http://joebon.cc/performance-optimization"></div>
      <!-- 多说评论框 end -->
      <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
      <script type="text/javascript">
        var duoshuoQuery = {short_name:"joebon"};
        (function() {
          var ds = document.createElement('script');
          ds.type = 'text/javascript';ds.async = true;
          ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
          ds.charset = 'UTF-8';
          (document.getElementsByTagName('head')[0]
          || document.getElementsByTagName('body')[0]).appendChild(ds);
        })();
      </script>
      <!-- 多说公共JS代码 end -->

    </div>

    <div class="sidenav">
       <iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=75&fansRow=2&ptype=1&speed=0&skin=1&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1742737645&verifier=a3b2e71b&colors=d6f3f7,ffffff,666666,0082cb,ecfbfd&dpc=1"></iframe>
    </div>

    <div class="sidenav">
        <h2>FE</h2>
        <ul class="artical-list">
        
            <li><a href="/performance-optimization">无线性能优化</a></li>
        
            <li><a href="/convert-numeric-chracter-reference-to-actual-character">将 NCR 字符转换为真实字符的方法</a></li>
        
            <li><a href="/page-render">当页面渲染时，浏览器发生了什么</a></li>
        
            <li><a href="/middleware&plugins">nodejs 中间件 & 插件</a></li>
        
            <li><a href="/comparing-escape-encodeURI-and-encodeURIComponent">字符编码扫盲及escape, encodeURI 和 encodeURIComponent方法比较</a></li>
        
            <li><a href="/upload-image-simulate-post-form">模拟form表单上传图片</a></li>
        
            <li><a href="/clipboard-image-upload">剪切板粘贴上传图片功能的实现</a></li>
        
            <li><a href="/date-cross-browser-safari-chrome">Date对象的浏览器兼容性问题</a></li>
        
            <li><a href="/js-scroll-direction">原生JS实现页面滚动方向检测</a></li>
        
            <li><a href="/commonjs-amd-cmd">前端模块化规范 - CommonJS、AMD & CMD</a></li>
        
            <li><a href="/cross-origin-js">JS跨域问题解决方式</a></li>
        
            <li><a href="/mac-os-x-shortcut">Mac OS X 快捷键</a></li>
        
            <li><a href="/nodejs-express-mongodb-website">nodejs+mongdb+express建站学习中所踩得坑</a></li>
        
            <li><a href="/introduction-to-svg">SVG入门</a></li>
        
            <li><a href="/cocos2d-event-dispatcher">Cocos2d-X 3.0 事件分发机制</a></li>
        
        </ul>

        <h2>Product</h2>
        <ul class="artical-list">
        
            <li><a href="/about-life-style">关于生活方式</a></li>
        
            <li><a href="/key-indicator-website-analysis">网站分析指标</a></li>
        
            <li><a href="/become-a-regular-worker">入职了，转正了</a></li>
        
            <li><a href="/about-method">关于方法</a></li>
        
            <li><a href="/about-thinking">关于思考</a></li>
        
        </ul>

        <h2>Life</h2>
        <ul class="artical-list">
        
            <li><a href="/hair-transplant">嗯，植发了</a></li>
        
            <li><a href="/a-meal-with-colleagues">和PD、运营、设计师和用研们的一顿饭</a></li>
        
            <li><a href="/first-douban-activity">第一次豆瓣活动：Coursera公开课之Public Speaking小分队——找回爱交流的自己</a></li>
        
            <li><a href="/restart">平凡之路，重新出发</a></li>
        
        </ul>
    </div>
</div>

<script src="/js/post.js" type="text/javascript"></script>


    <script type="text/javascript">
        $(function(){
            $('.home-follow').click(function(e){
                e.preventDefault();

                if($('.home-contact').is(':visible')){
                    $('.home-contact').slideUp(100);
                }else{
                    $('.home-contact').slideDown(100);
                }
            });
        })
    </script>

    <!--Google analytics站点统计-->
    <!--https://analytics.google.com/analytics/web/?et&authuser=0#management/Settings/a72552547w110260152p115008802/%3Fm.page%3DTrackingCode%26_r.ghFlowId%3D6324039/-->
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-72552547-1', 'auto');
        ga('send', 'pageview');

    </script>
</body>
</html>
